

# Chapter 6 : Nullspace-based Fault Diagnosis for Closed-Loop Mechatronic Systems with Application to Semiconductor Equipment

## 6.1 Introduction引言

除了参考文献有点价值外似乎没什么用。

## 6.2 Problem formulation问题描述

* [ ] 这些定理没有看证明

### 系统描述

闭环标称系统MIMO

对于标称系统，在理想模型假设下，可采用开环系统进行故障诊断滤波器设计[37]。考虑开环输出关系

$y = G_u u + G_d d + G_w w + G_f f$，(6.4)

而非闭环关系(6.1)和(6.2)。

#### 残差生成器和内部表示

为了检测和隔离故障，系统中引入了一个**残差生成器**（Residual Generator），它是一个由一个适当且稳定的 TFM $Q:=[\begin{matrix}Q_{y}&Q_{u}\end{matrix}]$ 描述的滤波器 。

* 残差 $\epsilon$ 的计算 (6.3):

  $$\epsilon=[\begin{matrix}Q_{y}&Q_{u}\end{matrix}][\begin{matrix}y\\ u\end{matrix}]$$

  残差 $\epsilon \in \mathbb{R}^{q}$ 用于对故障的**存在或缺失进行决策** 。

* 故障诊断滤器合成的开放回路系统 (Open-Loop System):

  在完美模型假设下，故障诊断滤波器的合成可以基于开放回路系统 17。

  $$\text{y}=G_{u}u+G_{d}d+G_{w}w+G_{f}f$$

* 内部表示 (Internal Representation) (6.5):

  将开放回路关系式 (6.4) 代入残差计算式 (6.3) 得到内部表示 $\epsilon=R\begin{bmatrix}u\\ d\\ w\\ f\end{bmatrix}$:

  $$\epsilon=[\begin{matrix}Q_{y}&Q_{u}\end{matrix}]\begin{bmatrix}G_{u}&G_{d}&G_{w}&G_{f}\\ I_{n_{u}}&0&0&0\end{bmatrix}\begin{bmatrix}u\\ d\\ w\\ f\end{bmatrix}=R\begin{bmatrix}u\\ d\\ w\\ f\end{bmatrix}$$

  20其中 $R$ 是残差 TFM， $R:=[\begin{matrix}R_{u}&R_{d}&R_{w}&R_{f}\end{matrix}]$ 。

  $R_{f_{j}}$ 表示故障 $f_{j}$ 到残差 $\epsilon$ 的 TFM 列 。

### 6.2.1 近似故障检测问题(AFDP)

Approximate fault detection problem (AFDP)

近似我理解的是后面AFDP的目标中包含的约等于，由于这个约等于，所以称为近似

一个有效设计的故障检测滤波器 $Q$ 需要解决**近似故障检测问题**（AFDP），其目标是使内部表示 $R$ 满足以下要求:

| **序号** | **要求**                                          | **含义**                                                     |
| -------- | ------------------------------------------------- | ------------------------------------------------------------ |
| **a)**   | $R_{u}=0$ 24                                      | **完全解耦**控制输入 $u$ 。                                  |
| **b)**   | $R_{d}=0$ 26                                      | **完全解耦**已知扰动 $d$ 。                                  |
| **c)**   | $R_{w}\approx0$, 且 $\text{Re}(\lambda(R_{w}))<0$ | 最小化噪声 $w$ 到残差 $\epsilon$ 的影响（噪声衰减），同时保持残差生成器的稳定性 。 |
| **d)**   | $R_{f_{j}}\ne0$, 且 $\text{Re}(\lambda(R_{f}))<0$ | 故障 $f$ 到残差 $\epsilon$ 的 TFM **显著非零**（故障敏感性），同时保持残差生成器的稳定性 。 |

**AFDP 的可解性：**

AFDP 是可解的当且仅当系统是完全故障可检测的（Completely Fault Detectable）。

* 完全故障可检测的条件 (Theorem 6.3):

  系统 (6.4) 是完全故障可检测的当且仅当对于所有 $j=1,...,n_{f}$，满足 $\text{rank}[G_{f_{j}}~G_{d}] > \text{rank}~G_{d}$ 。

  证明：证明过程参见[264, Theorem3.2]。

### 6.2.2 近似故障检测与隔离问题 (AFDIP)

Approximate fault detection and isolation problem (AFDIP)

比上面的6.2.1多了一个隔离问题

#### 系列滤波器

**为了有效隔离故障，需对残差信号实施专用结构，旨在确保残差$\varepsilon_i$受故障$f_j$的影响。**

为此，考虑$q$维残差向量$\varepsilon$，其结构为一组滤波器$Q^{(1)}$至$Q^{(q)}$，表示为

 $\boldsymbol{Q} = \begin{bmatrix} Q(1) & \ldots & Q(q) \end{bmatrix}$。(6.7)

相应的故障到残差传递函数矩阵具有类似的结构，即 

$\boldsymbol{R}_f = \begin{bmatrix} R_{f1}^{(1)} & \ldots & R_{fn_f}^{(1)} \\ \ldots & \ldots & \ldots \\ R_{f1}^{(q)} & \ldots & R_{fn_f}^{(q)} \end{bmatrix}$。(6.8)



残差和故障-残差 TFM 的结构 (6.7, 6.8):

残差向量 $\epsilon$ 被结构化为一系列滤波器 $Q^{(1)}$ 到 $Q^{(q)}$ 的堆叠 。



$$Q=\begin{bmatrix}Q^{(1)}\\ \vdots\\ Q^{(q)}\end{bmatrix}$$

对应的故障-残差 TFM $R_{f}$ 也具有类似结构 。

#### 结构矩阵

结构矩阵 $S_{R_{f}}$ (6.9a, 6.9b):

引入一个 $q \times n_{f}$ 的结构矩阵 $S_{R_{f}}$ 来定义 $R_{f}$ 的结构 。

$$S_{R_{f}}(i,j)=1 \quad \text{如果} \quad R_{f_{j}}^{(i)}\ne0$$

$$S_{R_{f}}(i,j)=0 \quad \text{如果} \quad R_{f_{j}}^{(i)}=0$$

#### **AFDIP 附加要求 (e)**

AFDIP 要求在满足 AFDP 的所有要求 a) 到 d) 的基础上，针对给定的结构矩阵S，确定一个稳定且真的滤波器Q，额外满足以下条件:

 **e)** $S_{R_{f}}=S$ (结构约束：实际结构与期望结构 $S$ 匹配)

根据[94]的命名法，对于期望的结构矩阵S，第i行称为第i个specifications，而第j列称为第j个故障特征。specifications主要用于综合，而故障特征主要用于隔离特定故障。这通过将触发（非零）残差的特征与S列中编码的特征进行比较来实现。

#### **AFDIP 的可解性：** AFDIP 是可解的当且仅当系统是 **S-故障可隔离的**

考虑以下定理，这些定理形式化地表明，如果系统具有S-故障可隔离性，则AFDIP是可解的。

**定理6.6**：对于给定的q×nf结构矩阵S，系统（6.4）具有S-故障可隔离性，当且仅当对于i =1,...,q，有$\text{rank}\begin{bmatrix} G_d & \hat{G}_d^{(i)} & G_{f_j} \end{bmatrix} > \text{rank}\begin{bmatrix} G_d & \hat{G}_d^{(i)} \end{bmatrix}$，∀j，$S_{ij} \neq0$，（6.10）其中$\hat{G}_d^{(i)}$由$G_f$中满足$S_{ij} =0$的列$G_{f_j}$构成。证明：证明参见[264, Theorem3.5]。

**定理6.7**：对于给定的结构矩阵S，AFDIP可解，当且仅当系统（6.4）具有S-故障可隔离性。证明：证明通过合并[264]中定理3.10和定理3.10的证明得到。理想情况下，可以同时隔离任意数量的故障。这一概念由强故障可隔离性定义，其结构S = Inf是可实现的（enforceable）。

**定理6.8**：系统（6.4）是强故障可隔离的，当且仅当 $\text{rank}\ G_d\ G_f = \text{rank}\ G_d + n_f$（6.11）证明：证明过程参见[264, Theorem3.6]。

通常，强隔离难以实现，尤其是当传感器数量远少于可能的故障数量时。在这种情况下，由于弱故障隔离的要求较低，因此仍可能实现。该方法需要构造一个列向量两两不同的结构矩阵\(S\)。允许隔离所有故障的限制性最小的结构是空心结构，表示为\(S = J_{nf} - I_{nf}\)，其中\(J\)是全1矩阵。在这种情况下，只有当一次发生单个故障时，故障才能成功隔离。

**推论6.9**：对于给定的\(n_f \times n_f\)空心结构矩阵\(S = J_{nf} - I_{nf}\)，系统（6.4）弱可隔离的充要条件是对于\(i, j =1, ..., n_f\)，有\(\text{rank}\begin{bmatrix} G_d & G_{f_i} & G_{f_j} \end{bmatrix} > \text{rank}\begin{bmatrix} G_d & G_{f_i} \end{bmatrix}, \forall i, j, i \neq j\)。（6.12）证明：该证明直接由定理6.6得出。对于每个\(i =1, ..., q\)，结构矩阵\(S_{ij} =0\)（若\(i = j\)），\(S_{ij} =1\)（若\(i \neq j\)）。由此可知，对于每个\(i\)，\(\hat{G}_{(i)}^d\)由\(\hat{G}_{(i)}^d = G_{f_i}\)构成，这直接得出式（6.12）。

接下来，给出近似故障检测与隔离问题的解决方案，然后研究特定的特殊情况。

## 6.3 Solution to the AFDIP

为了根据定理6.6为S-故障可隔离系统综合解决AFDIP的故障检测与隔离滤波器，滤波器组（6.7）中的每个滤波器i=1,…,q被分解为
\[Q^{(i)} = Q^{(i)}_3 Q^{(i)}_2 Q^{(i)}_1\]（6.13）
每个因子被解释为满足特定要求的部分综合结果。首先，对于特定的i，定义新的故障输入\(\hat{f}^{(i)}\)，它包含满足\(S_{ij}=1\)的分量\(f_j\)。将\(\hat{G}^{(i)}_f\)定义为由满足\(S_{ij}=1\)的列\(G_{f_j}\)组成的传递函数矩阵。现在考虑\(Q^{(i)} = \bar{Q}^{(i)}_1 Q^{(i)}_1\)，其中\(\bar{Q}^{(i)}_1 = Q^{(i)}_3 Q^{(i)}_2\)，\(Q^{(i)}_1\)是第一个部分综合结果，它构成一个真左有理零空间基，满足\[Q^{(i)}_1 G^{(i)} =0\]（6.14）其中\[G^{(i)} := \begin{bmatrix} G_u & G_d & \hat{G}^{(i)}_d \\ I_{n_u} &0 &0 \end{bmatrix}\]（6.15）



剩余的残差可以写为$\varepsilon_i = \bar{Q}^{(i)}_1 \bar{G}^{(i)}_f \hat{f}^{(i)} + \bar{Q}^{(i)}_1 \bar{G}^{(i)}_w w$，(6.16)其中$\bar{G}^{(i)}_f := Q^{(i)}_1 \begin{bmatrix} \hat{G}^{(i)}_f \\0 \end{bmatrix}$，$\bar{G}^{(i)}_w := Q^{(i)}_1 \begin{bmatrix} G_w \\0 \end{bmatrix}$。因子$Q^{(i)}_1$使用[261]中的方法计算，确保$\bar{Q}^{(i)}_1 \bar{G}_f$和$\bar{Q}^{(i)}_1 \bar{G}_w$是真有理和稳定的。对所有$i =1, \ldots, q$计算$Q^{(i)}_1$足以满足要求a)、b)和e)。得到的$\bar{Q}^{(i)}_1$可以分解为$\bar{Q}^{(i)}_1 = Q^{(i)}_3 Q^{(i)}_2$，其中$Q^{(i)}_2$是一个有理向量，用于构造$Q^{(i)}_1$基向量的线性组合，选择$Q^{(i)}_2$可以使$Q^{(i)}_2 Q^{(i)}_1$的麦克米伦阶数尽可能小。为此，采用最小动态覆盖算法[148,259]。或者，可以通过$Q^{(i)}_2$选择基向量的不同线性组合。接下来，确定$Q^{(i)}_3$以最大化故障噪声间隙$\eta := \frac{\beta}{\gamma}$。采用基于优化的方法来实现故障可检测性和噪声衰减之间的最大间隙。设$\gamma >0$是$w$对$\varepsilon_i$影响的可接受水平。为了最小化$w$的影响并最大化$\hat{f}^{(i)}$的影响，提出如下优化问题。给定$\gamma >0$，确定$\beta >0$和稳定且真有理的故障检测滤波器$Q^{(i)}_3$，使得$\beta = \max Q^{(i)}_3$，且$\| Q^{(i)}_3 Q^{(i)}_2 \bar{G}_f \|_\infty - \| Q^{(i)}_3 Q^{(i)}_2 \bar{G}_w \|_\infty \leq \gamma$，(6.17)，其中$Q(i)3 Q(i)2 \bar{G}_f \infty- := \min_{1 \leq i \leq q} Q(i)3 Q(i)2 \bar{G}_f \infty$。(6.18)该优化问题通过由共内-外分解确定$Q(i)3$来求解，即$Q(i)2 \bar{G}_f = G_{\text{wo}}G_{\text{wi}}$，其中$G_{\text{wo}}$是仅具有稳定零点的可逆TFM，$G_{\text{wi}}$是共内的（即$G_{\text{wi}}G_{\text{wi}}^H = I$，其中$H$表示厄米转置）。令$Q(i)3 = \gamma G_{\text{wo}}^{-1}$可得到(6.17)的最优解。计算该外因子通常仅需求解一个Riccati方程[101,157]。

**注6.10**：AFDIP的条件可以通过替换要求e)来放宽，即对应于\( S_{ij}=0 \)的传递函数矩阵\( R^{(i)}f_j \)不需要精确为零，即\( R^{(i)}f_j=0 \)，而只需较小，即\( R^{(i)}f_j\approx0 \)。为此，将\( \hat{G}^{(i)}_d \)视为\( G_w \)的一部分，在优化问题(6.17)中包含其贡献，而不是通过(6.14)强制其贡献为零。接下来，将考虑几种特殊情况及其与AFDIP可解性相关的含义。



第六章论文的 **6.3 Solution to the AFDIP**（近似故障检测与隔离问题的解）部分详细阐述了如何系统地合成能够解决 AFDIP 的故障检测和隔离滤波器。

核心思想是将构成残差生成器 $Q$ 的每个独立滤波器 $Q^{(i)}$ 进行**三阶段分解和综合**，每个阶段负责满足 AFDIP 的特定要求。



### 1. 滤波器分解与因子化



解决 AFDIP 的滤波器 $Q^{(i)}$ 被分解为三个级联的因子，其中 $i=1,...,q$ 代表残差 $\epsilon$ 的第 $i$ 个分量（或滤波器）1：



$$Q^{(i)}=Q_{3}^{(i)}Q_{2}^{(i)}Q_{1}^{(i)}$$

每个因子都对应一个解决特定要求的**部分综合结果** 2。





### 2. 第一步：$Q_{1}^{(i)}$ - 解耦与隔离（零空间基础）



目标：

$Q_{1}^{(i)}$ 的设计旨在满足 AFDIP 中关于完全解耦和故障隔离结构的要求：

1. **要求 a)**：解耦控制输入 $u$。

2. **要求 b)**：解耦已知扰动 $d$。

3. 

   **要求 e)**：根据期望的结构矩阵 $S$，将不应影响第 $i$ 个残差 $\epsilon_i$ 的特定故障 $f_j$（即 $S_{ij}=0$ 的故障）的影响解耦至零 3。

   

   

机制：





$Q_{1}^{(i)}$ 被合成为一个适当的左有理零空间基（proper left rational nullspace basis）444，它满足以下零空间条件：



$$Q_{1}^{(i)}G^{(i)}=0$$

5



其中，矩阵 $G^{(i)}$ 包含了所有需要从残差 $\epsilon_i$ 中解耦的信号的传递函数矩阵：





$$G^{(i)}:=\begin{bmatrix}G_{u}&G_{d}&\hat{G}_{d}^{(i)}\\ I_{n_{u}}&0&0\end{bmatrix}$$

66



* $G_{u}$ 和 $I_{n_{u}}$：用于解耦控制输入 $u$。

* $G_{d}$：用于解耦已知扰动 $d$。

* 

  $\hat{G}_{d}^{(i)}$：是由故障矩阵 $G_{f}$ 中那些**期望不影响**残差 $\epsilon_i$ 的列 $G_{f_{j}}$（对应 $S_{ij}=0$）组成的传递函数矩阵 7777。

  

  

结果：

计算出 $Q_{1}^{(i)}$ 后，残差 $\epsilon_{i}$ 将被简化，只受噪声 $w$ 和期望影响它的故障 $\hat{f}^{(i)}$ 的影响 8。



### 3. 第二步：$Q_{2}^{(i)}$ - 最小动力学覆盖



目标：

通过选择 $Q_{1}^{(i)}$ 的基向量的线性组合，使得 $Q_{2}^{(i)}Q_{1}^{(i)}$ 具有最小可能的 McMillan 阶数（即最小化滤波器的动态复杂性）99。

机制：





$Q_{2}^{(i)}$ 是一个有理向量，用于构造 $Q_{1}^{(i)}$ 基向量的线性组合 10101010。通过部署**最小动力学覆盖算法**（minimum dynamic cover algorithms）来实现 11。





### 4. 第三步：$Q_{3}^{(i)}$ - 故障检测与噪声衰减优化



目标：

确定 $Q_{3}^{(i)}$ 以满足 AFDIP 的其余要求：

1. **要求 c)**：最小化噪声 $w$ 的影响（$R_w \approx 0$）。

2. 要求 d)：最大化故障 $\hat{f}^{(i)}$ 的影响（$R_{f_j} \ne 0$）。

   即，最大化故障-噪声间隙 $\eta:=\frac{\beta}{\gamma}$ 12。

机制（优化问题）：

给定一个噪声影响的可容许水平 $\gamma>0$，通过以下优化问题确定最大的故障影响水平 $\beta>0$ 13131313：



$$\beta=\max_{Q_{3}^{(i)}}\{||Q_{3}^{(i)}Q_{2}^{(i)}\overline{G}_{f}||_{\infty-} \mid ||Q_{3}^{(i)}Q_{2}^{(i)}\overline{G}_{w}||_{\infty}\le\gamma\}$$

14



其中，$\overline{G}_{f}$ 和 $\overline{G}_{w}$ 是经过 $Q_{1}^{(i)}$ 作用后，从故障和噪声到中间残差的 TFM 15。



最优解：

该优化问题通过对 $Q_{2}^{(i)}\overline{G}_{f}$ 进行 共内-外因子分解（co-inner-outer factorization），即 $Q_{2}^{(i)}\overline{G}_{f}=G_{wo}G_{wi}$ 来解决 16。通过设置 $Q_{3}^{(i)}=\gamma G_{wo}^{-1}$ 即可获得最优解，这通常只需要求解一个 Riccati 方程 17。



### 5. 关于放松 AFDIP 要求的注释 (Remark 6.10)



论文还提到可以放宽 AFDIP 的结构要求 **e)** 18：



* **原始要求 e)**：不应受故障影响的残差分量 $R_{f_{j}}^{(i)}$ **严格为零**。

* 

  **放松要求**：允许 $R_{f_{j}}^{(i)}$ **近似为零**（$R_{f_{j}}^{(i)}\approx0$）19。

  

  

放松机制：

要实现这一放松，只需将 $\hat{G}_{d}^{(i)}$（原本需要严格解耦的故障）视为噪声 $G_{w}$ 的一部分 20。这样，就不通过零空间条件 (6.14) 强制其贡献为零，而是将其贡献纳入优化问题 (6.17) 中，使其与噪声一起被最小化 21。



## 6.4 Design for actuator and sensor faults

本节考虑了三种常见情况，每种情况都有一组不同的故障。首先，仅考虑执行器故障。其次，仅考虑传感器故障，最后考虑两者的组合。对于每种情况，将AFDIP的可解性要求转化为可接受的结构矩阵S，以及其对故障诊断系统设计的影响。为了揭示基本局限性，本节其余部分假设Gd为空集。做出这一假设是因为这些干扰可以在Gw中捕获，从而将它们从可解性条件中移除，并通过优化问题（6.17）解决，参见Remark6.1 [264]。

推论6.11：对于给定的q×nf结构矩阵S和nu=0，模型是S故障可隔离的，当且仅当对于i=1,...,q，有\[ \text{rank}\begin{bmatrix} \hat{G}^{(i)}_d & G_{f_j} \end{bmatrix} > \text{rank}\begin{bmatrix} \hat{G}^{(i)}_d \end{bmatrix}, \quad \forall j, S_{ij} \neq0, \quad (6.19) \]其中，\( \hat{G}^{(i)}_d \)由Gf中满足Sij=0的列Gfj构成。证明：令Gd={}，由定理6.6可直接得证。

### 6.4.1 执行器故障

考虑由式(6.4)描述的系统发生执行器故障，即\( n_f = n_u \)，并采用\( n_y \times n_u \)故障模型\( G_{\text{act}f} = G_u \)。不失一般性，将其分解为\[G_{\text{act}f}(s) = \frac{1}{d(s)} \begin{bmatrix}N_{11}(s) & \ldots & N_{1nu}(s) \\\vdots & \ddots & \vdots \\N_{ny1}(s) & \ldots & N_{nynu}(s)\end{bmatrix}, \quad (6.20)\]其中\( d(s) \)为公分母多项式，\( N(s) \)为分子多项式矩阵。

**推论6.12**：仅含执行器故障的系统是强故障可隔离的，即能实现\( S = \text{Inf} \)，当且仅当\(G_f\)中所有故障列线性无关且\( n_y \geq n_u \)。

​	**证明**：由定理6.8可直接得证。令\( G_d = \{\} \)，则系统强故障可隔离当且仅当\( \text{rank}G_f = n_f \)。为满足此条件，\(G_f\)必须列满秩且传感器数量至少与故障数量相等，即\( n_y \geq n_f = n_u \)。

因此，传感器的数量必须大于或等于可能发生故障的执行器数量。此外，$G_f$必须为列满秩。通常$n_y \ngeq n_u$。为此，考虑最宽松的隔离要求。

**推论6.13**：仅存在执行器故障的系统是弱可隔离的，其中$S = J_{nf} - I_{nf}$，当且仅当所有故障列$G_{fj}$（$j =1, \ldots, n_f$）两两独立且$n_y \geq2$。

​	**证明**：证明过程遵循定理6.6。首先令$ G_d = \{\} $。现在，考虑式（6.10），其中$ \hat{G}^{(i)}_d $由满足$S_{ij} =0$的$G_f$的列$G_{fj}$构成。在这种情况下，对于每个$i =1, \ldots, q$，只有$S_{ii} =0$，这意味着对于每一行，式（6.10）需满足$\text{rank}\begin{bmatrix} G_{fi} & G_{fj} \end{bmatrix} > \text{rank}\ G_{fi} =1$对所有$j \neq i$成立。后者等价于验证所有故障列$G_{fj}$（$j =1, \ldots, n_f$）是否两两独立且$n_y \geq2$。

因此，为了能够以限制性最小的结构隔离所有故障，只需满足两两独立性即可。隔离任意数量的执行器故障至少需要两个传感器。注意，单执行器情况$n_u =1$已在推论6.12中涵盖，其中$S =1$，因此$n_y \geq1$即可满足要求。

**例6.14**：考虑一个具有两个传感器和五个易发生故障的执行器的系统。因此，$p=2$，$n_u = n_f=5$。由于$n_u > n_y$，即无法实现$S = I_{nf}$，因此该系统永远不会是强故障可隔离的。然而，当且仅当所有故障列$G_{fj}$两两独立时，该系统是弱故障可隔离的，且$S = J_{nf} - I_{nf}$。



### 执行器故障gemini回答

好的，以下是第六章论文中 **6.4.1 Actuator faults**（执行器故障）部分内容的详细解释。

本节专门讨论系统只受到**执行器故障**（Actuator Faults）影响时的故障诊断设计条件，旨在将通用的 AFDIP 可解性要求转化为针对执行器故障的特定条件。



#### 1. 执行器故障模型



在本节中，假设系统（由式 (6.4) 描述）只受到执行器故障的影响。

* **故障数量 $n_f$**：等于执行器数量 $n_u$，即 $n_{f}=n_{u}$。

* 故障模型 $G_{f}^{\text{act}}$：执行器故障模型 $G_{f}^{\text{act}}$ 等于控制输入到输出的传递函数矩阵 $G_{u}$。

  

  $$G_{f}^{\text{act}}(s)=G_{u}$$

* 传递函数矩阵 $G_{f}^{\text{act}}(s)$ 的结构 (6.20)：

  

  $$G_{f}^{\text{act}}(s)=\frac{1}{d(s)}\begin{bmatrix}N_{11}(s)&\dots&N_{1n_{u}}(s)\\ \vdots&&\vdots\\ N_{n_{y}1}(s)&\dots&N_{n_{y}n_{u}}(s)\end{bmatrix}$$

  其中 $d(s)$ 是一个公分母多项式，$N(s)$ 是由分子多项式组成的矩阵 1。

  

  



#### 2. 基本假设



为了揭示系统的基本限制，本节假设**已知扰动 $G_d$ 为空集** 2。这是因为这些扰动可以被归入噪声 $G_w$ 中，通过优化问题 (6.17) 来处理，从而从 AFDIP 的可解性条件中移除 3。



在这种假设下，AFDIP 的可解性条件（S-故障可隔离性，Theorem 6.6）简化为 **Corollary 6.11**：

$$\text{rank}[\hat{G}_{d}^{(i)}~G_{f_{j}}]> \text{rank}[\hat{G}_{d}^{(i)}] \quad \forall j, S_{ij} \ne 0$$



其中 $\hat{G}_{d}^{(i)}$ 是由 $G_{f}$ 中那些 $S_{ij}=0$ 的列组成的。



#### 3. 强故障可隔离性 (Strong Fault Isolability)



**强故障可隔离性**要求能够隔离**任意数量**的故障，对应于结构矩阵 $S=I_{n_{f}}$（单位矩阵）。

* 条件 (Corollary 6.12)：

  一个只有执行器故障的系统是强故障可隔离的（即 $S=I_{n_{f}}$ 可实现）当且仅当满足以下两个条件 4：

  1. $G_{f}$ 中的**所有故障列是线性独立的**。

  2. 

     **传感器数量大于或等于执行器（故障）数量**，即 $n_{y}\ge n_{u}$ 5555。

     

     

* 推导：

  根据 Theorem 6.8，当 $G_{d}=\{\}$ 时，系统强故障可隔离的条件简化为 $\text{rank}~G_{f}=n_{f}$ 6。

  要满足 $\text{rank}~G_{f}=n_{f}$，则 $G_{f}$ 必须是列满秩的，并且至少有与故障数量（即执行器数量）一样多的传感器 7。



#### 4. 弱故障隔离性 (Weak Fault Isolability)



由于在许多实际应用中，$n_{y} \ne n_{u}$（例如执行器数量多于传感器数量），因此强隔离往往不可实现 8。在这种情况下，考虑**最不严格**的隔离要求，即**弱隔离性**，它对应于**空心结构** $S=J_{n_{f}}-I_{n_{f}}$。



* 条件 (Corollary 6.13)：

  一个只有执行器故障的系统是弱可隔离的（即 $S=J_{n_{f}}-I_{n_{f}}$ 可实现）当且仅当满足以下两个条件 99：

  1. **所有故障列 $G_{f_{j}}$ 都是两两独立的**（pairwise independent）。

  2. 

     **至少需要两个传感器**，即 $n_{y}\ge 2$ 10101010。

     

     

* 推导：

  对于空心结构 $S=J_{n_{f}}-I_{n_{f}}$，对于任意一行 $i$，需要解耦的故障列 $\hat{G}_{d}^{(i)}$ 仅包含 $G_{f_{i}}$（因为只有 $S_{ii}=0$） 11111111。

  因此，S-故障可隔离条件 (6.10) 简化为对所有 $j \ne i$ 检验：

  

  $$\text{rank}[\begin{matrix}G_{f_{i}}&G_{f_{j}}\end{matrix}]>\text{rank}[G_{f_{i}}]=1 \quad \forall j\ne i$$

  这等价于要求所有故障列 $G_{f_{j}}$ **两两线性独立**，并且传感器数量 $n_{y}$ 至少为 2 12。

  

  

* 特殊情况 ($n_u=1$)：

  如果只有一个执行器 ($n_u=1$)，则只需要 $n_{y}\ge 1$ 即可 13。



#### 5. 案例示例 (Example 6.14)



* 

  **系统配置：** 两个传感器 ($n_{y}=2$) 和五个执行器 ($n_{u}=n_{f}=5$) 14。

  

  

* 

  **强隔离性：** 永远不可能是强故障可隔离的，因为 $n_{u}>n_{y}$（$5>2$），即 $S=I_{n_{f}}$ **不可实现** 15。

  

  

* 

  **弱隔离性：** 如果所有故障列 $G_{f_{j}}$ 都是**两两独立**的，则系统是弱故障可隔离的（$S=J_{n_{f}}-I_{n_{f}}$ 可实现） 16。

  

  

### 6.4.2 传感器故障

接下来，设由式（6.4）描述的系统存在传感器故障，即\(n_f = n_y\)，并考虑\(n_y \times n_y\)的故障模型\(G_{\text{sens}f}(s) = \begin{bmatrix}1 & \ldots &0 \\ \ldots & \ldots & \ldots \\0 & \ldots &1 \end{bmatrix}\)（6.21）

**推论6.15**：仅存在传感器故障的系统本质上是强故障可隔离的。

​	证明：该证明直接由定理6.8得出。令\( G_d = \{\} \)，则系统强故障可隔离的充要条件为\(\text{rank}\, G_f = n_f\)。由于\(G_f = I_{n_f}\)，此条件始终成立。

注意，$G_{\text{sens}} f(s)$的列向量本质上是线性无关的。对执行器数量没有额外要求。显然，如果系统具有强故障隔离性，那么要求较低的结构S也是可行的，例如推论6.9中的空心结构。

### 6.4.3 执行器和传感器故障

最后，设由式（6.4）描述的系统存在执行器和传感器故障，即 \( n_f = n_u + n_y \)，并考虑 \( n_y \times (n_u + n_y) \)故障模型 \( G_f = \begin{bmatrix} G_{\text{act}f}(s) & G_{\text{sens}f}(s) \end{bmatrix} \)，不失一般性，可分解为：

\[G_f(s) = \frac{1}{d(s)} \begin{bmatrix}N_{11}(s) & \ldots & N_{1n_u}(s) & d(s) & \ldots &0 \\\vdots & \ddots & \vdots & \vdots & \ddots & \vdots \\N_{n_y1}(s) & \ldots & N_{n_yn_u}(s) &0 & \ldots & d(s)\end{bmatrix}. \quad (6.22)\]

**推论6.16**：存在传感器和执行器故障的系统永远不具有强故障隔离性。

​	**证明**：由定理6.8直接可得，其中 \( n_f = n_u + n_y \)。令 \( G_d = \{\} \)，则系统具有强故障隔离性当且仅当 \(\text{rank}\, G_f = n_f\)。由于 \( \text{rank}\, G_f \leq n_y \)且 \( n_f = n_u + n_y \)，因此所有执行器和传感器均易发生故障的系统永远不具有强故障隔离性。

**推论6.17**：所有传感器和执行器均易发生故障的系统，当且仅当所有故障列 \( G_{fj} \, (j =1, \ldots, n_f) \)两两独立且 \(n_y \geq2\)时，在 \( S = J_{n_f} - I_{n_f} \)下具有弱隔离性。

​	**证明**：证明过程由定理6.6可得。首先令 \( G_d = \{\} \)。考虑式（6.10），其中 \( \hat{G}_{(i)d} \)由满足 \(S_{ij} =0\) 的 \(G_f\) 的列 \(G_{fj}\)构成。此时，对每个 \(i =1, \ldots, q\)，仅有 \(S_{ii} =0\)，即每行式（6.10）等价于验证：\[\text{rank}\, \begin{bmatrix} G_{fi} & G_{fj} \end{bmatrix} > \text{rank}\, G_{fi} =1 \quad \forall j \neq i. \quad (6.23)\]上式等价于所有故障列 \( G_{fj} \, (j =1, \ldots, n_f) \)两两独立且 \(n_y \geq2\)。

因此，为了能够以限制性最小的结构隔离所有故障，只需要成对独立性。隔离任意数量的故障至少需要两个传感器。注意，单个传感器\( n_y =1 \)的情况永远不够，因为不等式6.23的两边都是秩1。

**例6.18**：一个具有一个传感器和\( n_u \)个执行器且所有执行器都可能发生故障的系统永远无法实现故障隔离。无论是\(S = I_{nf}\)还是\(S = J_{nf} - I_{nf}\)都无法实现，因为\(G_f\)中的列总是成对相关的。

**例6.19**：一个具有多个传感器和多个执行器的系统，例如$n_y=3$，$n_u=3$，所有传感器和执行器都可能发生故障，当且仅当$j=n_y+n_u=1,\dots,6$的列$G_{fj}$两两独立时，该系统是故障可隔离的。

如果AFDIP不可行，本节介绍的分析方法可能会为在哪里放置额外的传感器以解决AFDIP提供见解。接下来，将所提出的方法应用于一个具有17种不同执行器和传感器故障的大规模高精度机电系统。

## 6.5实验结果

同时包含执行器和传感器故障

本节利用半导体行业的原型晶圆台对所提方法进行验证。该系统配备4个传感器和13个执行器，均假设易发生故障，因此第6.4.3节中的分析适用。首先，介绍系统及其控制算法。在此之后，给出系统的精确模型。随后，设计定制的FDI滤波器以证明故障诊断方法的有效性。主要目标是检测和隔离每个执行器和传感器的故障。

### 6.5.1晶圆平台原型机和控制算法

考虑图6.2所示原型晶圆台的概况。力框架和晶圆台底部的特写分别如图6.3和图6.4所示。晶圆台是装置中唯一的运动部件，由重力补偿器悬浮，以减小所需的执行器力。在本实验案例研究中，仅考虑面外方向的执行器和传感器。在该方向上，晶圆台的位置由四个具有纳米分辨率的线性编码器测量，其中一个如图6.2所示。图6.3中可见其中两个编码器。系统在该方向上由13个洛伦兹执行器驱动。图6.3中可见13个线圈，卡盘上的接口如图6.4所示。系统通过分散式PID控制器在所有六个自由度（DOFs）上进行控制。为此，系统分别使用输入和输出变换矩阵Tu和Ty进行解耦，见图6.5。每个自由度由专用的C语言PID控制器控制，采样频率为10 kHz。系统在面外方向上遵循平滑的4阶设定点，行程为100 μm，频率为1 Hz。其他2个平移自由度和3个旋转自由度被调节为零。主要目的是检测和隔离所有13个面外执行器和4个面外传感器的故障。



本节 **6.5 Experimental results**（实验结果）旨在通过在一个大规模高精度机电系统——**半导体晶圆平台原型机**上应用所提出的基于零空间的故障检测与隔离（FDI）方法，来验证其有效性。

* **研究对象：** 仅考虑**平面外方向**（out-of-plane direction）的执行器和传感器 3。
* **系统配置：**
  * **传感器 ($n_y$)：** 4 个线性编码器，用于测量晶圆台的位置，分辨率达到纳米级。
  * **执行器 ($ n_u $)：** 13 个洛伦兹（Lorentz）执行器用于驱动平台。
  * **总故障数 ($n_f$)：** 13 个执行器故障和 4 个传感器故障，总计 **17 个** 不同的故障 ($f_1$ 到 $f_{17}$) 。
* **控制系统：** 平台由一个分散式（decentralized）PID 控制器控制所有六个自由度（DOFs）。
* **控制目标：** 主要目的是检测和隔离所有 13 个平面外执行器和 4 个平面外传感器中的故障。

* * 

    

    







<img src="C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251117173315245.png" alt="image-20251117173315245" style="zoom:67%;" />

图6.2：原型实验晶圆台装置。运动部件卡盘由a指示，其通过重力补偿器悬挂在力框架b上，力框架b位于基础框架c的顶部。目前，卡盘和力框架已滑出机器，而在运行期间，它们位于测量框架d的下方。测量框架通过空气弹簧e与固定环境隔离开来。水平面内有四个洛伦兹执行器，其中一个由f指示。这些执行器向卡盘施加切向力。垂直面内的执行器位于卡盘和力框架之间。卡盘的位置在水平面内通过电容传感器测量，在垂直面内通过线性编码器测量。卡盘有四个光栅尺g，由测量框架上的编码器h进行测量。

![image-20251117173426945](C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251117173426945.png)

图6.3：卡盘下方力框架的特写。重力补偿器与力框架的接口由a指示。用于在垂直方向移动卡盘的十三个洛伦兹执行器之一由b指示。一个面内执行器的位置由c指示。

<img src="C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251117173451723.png" alt="image-20251117173451723" style="zoom:80%;" />

图6.4：卡盘底部特写。重力补偿器与卡盘的接口由a指示，洛伦兹致动器的接口由b指示。面内致动器的接口由c指示。

<img src="C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251117173551063.png" alt="image-20251117173551063" style="zoom:80%;" />

图6.5：闭环模态控制原型晶圆平台系统框图。13个执行器故障和4个传感器故障分别由f1至f17表示。增强残差发生器在（）中突出显示。

### 6.5.2系统辨识（暂时不太懂，而且也不是这里的重点）

采用闭环多正弦辨识实验，通过鲁棒方法[202]获取最佳线性近似（BLA）。该频率响应函数（FRF）用于拟合20阶模态参数模型，记为\( G_u \)。为此，使用一种基于简化改进工具变量法（SRIVC）和集成预测误差最小化（IPEM）的新型模态辨识算法。该算法（包括详细分析）将在其他文献中发表。此算法是文献[112]的多输入多输出（MIMO）频域扩展，详见文献[46]中关于FRF辨识的内容。20阶模型\( \hat{G}_u: {u_1 \ldots u_{13}}^\top \to {y_1 \ldots y_4}^\top \)如图6.6所示，其与实测FRF高度吻合，尤其在至少约2000 Hz以下频段，并作为故障检测与隔离（FDI）滤波器设计的基础。

------

在进行 FDI 滤波器设计之前，需要一个精确的系统模型。

* **方法：** 通过闭环多正弦（multisine）辨识实验获得了系统的最佳线性近似（BLA）。
* **模型：** 使用该频率响应函数（FRF）拟合了一个 20 阶的模态参数模型，将其作为植物传递函数矩阵 $ G_u $ 。
* **输入/输出：** 该 20 阶模型 $\hat{G}_u$ 是一个 $u_1 \dots u_{13}^T \rightarrow y_1 \dots y_4^T$ 的模型（13 个输入到 4 个输出） 。
* **准确性：** 该模型与测量的 FRF 高度吻合，特别是在高达约 2000 Hz 的频率范围内 。





### 6.5.3 FDI设计

------

利用辨识出的低阶模型 $\hat{G}_u$ 来综合 FDI 滤波器，

* **故障模型：** 将执行器故障转移到被控对象的传感器侧，得到故障模型 $G_f$ ，$G_f$结合了执行器故障 $G_{f}^{\text{act}}$ 和传感器故障 $G_{f}^{\text{sens}}$，即 $G_f = [G_{f}^{\text{act}} \ G_{f}^{\text{sens}}]$，其中 $G_{f}^{\text{act}} = G_u$ 且 $G_{f}^{\text{sens}} = I_4$（4x4 单位矩阵）。

* **扰动/噪声：** 由于传感器质量较高，未考虑干扰和噪声影响，因此$G_d$和$ G_w $被选为零矩阵。

* **隔离性分析：** 根据第 6.4.3 节的分析（推论 6.16），该系统（总故障数 $n_f=17$ 远大于传感器数量 $n_y=4$）**无法实现强故障隔离性** 。

* **结构矩阵 $S$：** 因此，采用了限制较少的结构矩阵 $S$——一个 **几乎空心（almost hollow）** 的特征矩阵。

  <img src="C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251117173802149.png" alt="image-20251117173802149" style="zoom: 67%;" />

  * 该矩阵 $S$ 的维度为 $17 \times 17$，代表 17 个残差输出（$\epsilon_1$ 到 $\epsilon_{17}$）与 17 个故障输入的关联 1717。
  * 该矩阵除了对角线和右上角部分有零元素外，其余大部分为 1 18181818。
  * **特殊零点：** $S$ 矩阵右上角的零点（$S_{1,14}$ 到 $S_{4,17}$）是为了确保前四个残差信号 ($\epsilon_1$ 到 $\epsilon_4$) 与传感器故障 ($f_{14}$ 到 $f_{17}$) 解耦 。
  * 利用这种结构S，采用6.3节中描述的方法综合出一个近似故障检测与隔离滤波器。



### 6.5.4实验时域结果 

------







图6.7：残差信号ε1至ε17（）的绝对值和归一化值。利用（6.25）中的结构可以轻松定位故障。尽管存在故障，但预期残差为零的相应区域用垂直线（）表示。



* **故障注入方式：**

  * **执行器故障（$f_1$ 到 $f_{13}$）：** 依次注入，幅值为 0.1 N 的阶跃信号。
  * **传感器故障：** 依次注入，幅值为 10 µm 的阶跃信号 。
  * **时序：** 第一个故障在 $t=2.5$ s 注入（持续到 $t=7.5$ s），随后每个故障间隔 5 s 注入。

  残差信号的绝对值和归一化值如图6.7所示。显然，故障易于检测，通过比较触发信号和S中的结构可以观察到故障的根本原因。例如，在t=5 s左右，残差ε2至ε17产生响应，而ε1≈0，类似于第一个执行器处的加性故障。所获得的残差信号可以轻松处理为指示当前故障位置的布尔信号。

  ![image-20251117174212701](C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251117174212701.png)

* **主要发现：**

  * **可检测性和隔离性：** 故障很容易被检测到。通过将触发（非零）的残差信号与 $S$ 矩阵的结构进行比较，可以观察到故障的根本原因（root cause）。
  * **隔离示例：** 例如，在 $t=5$ s 左右，残差 $\epsilon_2$ 到 $\epsilon_{17}$ 都有反应，而 $\epsilon_1 \approx 0$，这与第一个执行器发生附加故障的特征一致（符合 $S$ 矩阵的第一列签名）。
  * **执行器故障残差：** 持续性的执行器故障（如阶跃或正弦信号）会产生**持续的**（asymptotically non-vanishing）残差信号 27。
  * **传感器故障残差：** 传感器故障缺乏**强故障可检测性**，因此检测难度稍大。其影响仅在故障**瞬态**（transient）期间体现在残差中，随后残差信号会随时间消失。
  * **模型失配：** 在无故障情况下，残差信号仍表现出微小的振荡，周期与参考信号相似。这归因于**模型与实际不匹配**（model-reality mismatch），导致解耦特性轻微受损，并引起参考信号 $r$ 轻微泄漏到残差信号中。
  * **结论：** 尽管存在模型失配等影响，但通过适当处理残差，所有故障都被成功检测和隔离，证明了该方法在高精度工业设备中的适用性。

在无故障情况下，残差信号表现出小幅振荡，特别是具有与参考值相似的周期。这种不良影响归因于模型与实际的不匹配，导致解耦特性略有违背，并造成r少量泄漏到残差信号中。

在持续故障激励情况下，执行器故障会产生持续的残差信号。这意味着在阶跃或正弦信号等持续故障情况下，残差信号渐近非零。传感器故障的故障可检测性较弱，使得检测难度稍大，因为其影响仅在故障暂态期间体现在残差中，因此残差中的影响会随时间消失，详见[264, Chapter3]。然而，通过对残差进行适当处理，可以检测和隔离所有故障，这表明该方法适用于高精度工业设备。





# \(G_f\)故障传递函数矩阵<span style="color:#FF0000;">列线性独立=\(G_f\)列满秩</span>

这个要求触及了故障诊断理论中的一个核心概念，即**故障的可区分性**（Fault Distinguishability）。

所谓的“$G_{f}$ 中的所有故障列是线性独立的”指的是：

### 1. 概念定义：有理线性独立性

在控制理论和系统分析中，矩阵 $G_{f}$ 是一个**传递函数矩阵 (Transfer Function Matrix, TFM)**，其元素是关于拉普拉斯变量 $s$ 的有理函数（即 $G_{f}(s)$）。因此，这里的线性独立性指的是**有理线性独立性**。

**数学表述：**

$G_{f}$ 是一个 $n_y \times n_f$ 的矩阵，其列向量表示为 $G_{f_1}, G_{f_2}, \dots, G_{f_{n_f}}$。

如果存在一组**有理函数（或多项式）系数** $\alpha_1(s), \alpha_2(s), \dots, \alpha_{n_f}(s)$，使得这些故障列的线性组合为零向量：

$$\alpha_1(s) G_{f_1}(s) + \alpha_2(s) G_{f_2}(s) + \dots + \alpha_{n_f}(s) G_{f_{n_f}}(s) = 0$$

那么，要满足“所有故障列是线性独立的”，则唯一的解必须是所有系数 $\alpha_j(s)$ 恒为零：

$$\alpha_1(s) = \alpha_2(s) = \dots = \alpha_{n_f}(s) = 0$$

### 2. 物理和诊断意义：故障的可区分性

在故障诊断的背景下，线性独立性具有至关重要的物理意义：

#### a) 唯一的故障特征（Unique Signature）

* **$G_{f_j}$** 向量（第 $j$ 列）表示第 $j$ 个故障 $f_j$ 发生时，系统**所有 $n_y$ 个传感器**上的输出响应（或称为**故障特征**）。
* <span style="color:#FF0000;">线性独立性</span>要求每个故障 $f_j$ 产生的输出特征（或影响模式）是**独一无二**的。**没有任何一个故障**对输出的影响，可以用**其他故障**对输出的影响的线性组合（即同时发生的一组其他故障）来完美复制。

#### b) 可隔离性的基础

* **如果**故障列是**线性相关**的（即存在非零的 $\alpha_j(s)$ 使得组合为零），这意味着：
  * 多个故障的组合效应（例如 $\alpha_1 f_1 + \alpha_2 f_2$）可能与**零故障**（无故障）的情况在输出上完全相同。
  * 或者，一个故障 $f_1$ 的影响可以被其他故障 $f_2, f_3, \dots$ 的组合所精确掩盖或复制。
* 在这种情况下，故障检测滤波器 $\epsilon$ 永远无法区分这些线性相关的故障，更无法将它们相互隔离，因为它们产生的残差模式是**混叠**（aliased）或**冗余**的。

### 3. 与矩阵秩（Rank）的关系

“$G_{f}$ 中的所有故障列是线性独立的”这一条件，严格等价于 $G_{f}$ 矩阵是**列满秩**的：

$$\text{rank}(G_{f}) = n_{f}$$

其中：

* $\text{rank}(G_{f})$：矩阵 $G_{f}$ 的秩。
* $n_{f}$：故障的数量（在本节执行器故障中，$n_{f}=n_{u}$，即执行器的数量）。

#### 为什么这对强隔离至关重要？

在 **6.4.1 节**中，**强故障可隔离性** (Strong Fault Isolability, $S=I_{n_f}$) 的要求是：

$$\text{rank}[G_{f}]=n_{f} \quad \text{且} \quad n_{y}\ge n_{u}$$

1. **$\text{rank}[G_{f}]=n_{f}$ (线性独立性)：** 保证了系统中故障特征的多样性和独立性，是**区分**所有 $n_f$ 个故障的必要条件。
2. **$n_{y}\ge n_{u}$ (传感器数量)：** 保证了系统有足够多的观测维度（传感器）来捕捉这些独立的故障特征。如果 $n_y < n_u$，则 $G_f$ 不可能是列满秩的，必定存在线性相关性，因此无法实现强隔离。