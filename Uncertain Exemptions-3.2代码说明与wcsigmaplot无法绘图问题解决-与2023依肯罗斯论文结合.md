师兄的仿真文件是 sim2.slx，这个文件里看似 GdGfGu 都是含不确定性 a 的传递函数，但实际上在 test 文件中，取了 a =-1（相当于是最坏值），然后跑仿真实际上只是跑了没有不确定性的传递函数的仿真。

并且如果继续取 a = 1*ureal('a',0); 则跑仿真会出错，因为师兄的仿真用的是 Transfer Fcn，不能加入不确定性。

但我觉得不一定这样（先得出最坏，再跑单个）就是不行，反而我觉得还挺有效率。

要是改进的话，可以求出最坏的然后直接把值赋给仿真，这样不用手动调整值的大小。



# main.m 中

## 扩展扰动矩阵鲁棒不稳定（已经解决）

验证了一下，师兄的 G2d 也是不稳定，没有报错只是因为师兄只用了 wcgain 没有用 wcsigmaplot，我看了下师兄 wcgain 的 info，也是上下界都是无穷，找不到最坏频率

```matlab
wcsigmaplot(G2d,{0.1,100}) 
错误使用 DynamicSystem/wcsigmaplot
System is not robustly stable for the specified uncertainty level (worst-case gain is infinite).
Use WCSIGMAPLOT(UFRD(SYS,FGRID)) to analyze gain variations in unstable or marginally stable systems.
```

```
  包含以下字段的 struct:

                 Model: 1
             Frequency: NaN
                Bounds: [Inf Inf]
     WorstPerturbation: [1×1 struct]
           Sensitivity: [1×1 struct]
    BadUncertainValues: [1×1 struct]
            ArrayIndex: 1
```

这个鲁棒不稳定是很难解决的，因为 G2d 或者说 Gd_sdelta 是通过原不确定性传递函数 Gyd 通过各种运算得到的，其不是一个系统（或许有办法看成系统？但是也不知道，可能也不应该根据 Gd_sdelta 的稳定性来设计原系统的鲁棒控制器，这样是不对的，会损害原系统的性能，而我只是为了故障检测，肯定不能改变原系统啊），我没有办法对其设计控制器，没有办法保证其是稳定的。不过或许这里就是一个创新点？如何通过对 Gd_sdelta 进行设计/重构，得到能够进行 wcgain 和 wcsigmaplot 的新的 Gd_sdelta，也满足最终最优故障检测滤波器设计？

可是那师兄怎么知道最坏增益点在哪？知道最坏增益点在哪真的有意义吗（在很多点都是上下界无穷的情况下）？难道是相对在哪？

通过看埃因霍温的论文，发现他们取的频率范围是 10^{-2}~ 10^{3}，我怀疑是不是不该取所有频率，而且奇异值过大可能是因为用于求解的频率范围有问题（因为我这里并没有设定频率范围，我应该尝试设定一下）。**是因为太低频会出现数值计算问题？这是我的疑问**

![image-20251110142958942](C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251110142958942.png)

# 如果我连最坏增益都求不出来，最坏频率在哪我都求不了，那我怎么求上界啊？

那2023依肯罗斯里是怎么得到这个解，这个滤波器的呢？![image-20251110173102158](C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251110173102158.png)

```matlab
% Qol = tf([1 3 2],[1 3.078 2.236]);
% Qcl = tf([1 4 4.628 1.257],[1 4.105 4.054 0.8886]);
```



* [x] 再看一遍论文里怎么整的，也有可能是控制器问题？但是系统本身应该是稳定的吧？是的，经过下面代码验证，原系统在不确定性范围内是鲁棒稳定的（其实自己也很容易得到）

  ```
  >> [stabmarg, ~, ~] = robstab(feedback(Gu * K, 1));
      if stabmarg.LowerBound > 1
          fprintf('系统在不确定性范围内鲁棒稳定\n');
      else
          fprintf('系统在部分不确定性条件下可能不稳定\n');
      end
  系统在不确定性范围内鲁棒稳定
  ```

  * [x] 再看一遍论文里怎么整的（已解决）

# wcgain 的原理是什么？

`wcgain` 的核心原理是基于 **结构奇异值(μ)分析**，具体来说：

### 1. **数学基础**

* 对于不确定系统，`wcgain` 计算的是系统的 **最坏情况 H∞ 范数**
* 使用 **结构奇异值(μ)** 理论来边界最坏情况增益
* 基于 **上界/下界算法** 来保证结果的可靠性

### 2. **计算过程**

```
% wcgain 内部大致执行以下步骤：
1. 将不确定系统转换为 LFT（线性分式变换）形式
2. 在频率网格上计算结构奇异值 μ
3. 找到使 μ 最大的频率和不确定性组合
4. 返回上界(UpperBound)和下界(LowerBound)
```

### 3. **关键特性**

* **上界保证**：真实最坏情况增益 ≤ UpperBound
* **下界保证**：真实最坏情况增益 ≥ LowerBound
* **临界频率**：最坏情况增益发生的频率点

## 其底层计算 (wcgain_)是我看不了的

不直接对用户开放

```matlab
>> help wcgain_
--- umat/wcgain_ 的帮助 ---

  Worst-case gain analysis

    wcgain_ 的其他用法

       InputOutputModel/wcgain_

--- InputOutputModel/wcgain_ 的帮助 ---

InputOutputModel/wcgain_ 是未公开的内置 InputOutputModel method。
```







只能说大致了解一下过程，帮助理解，实际上没什么作用

# wcgain_底层计算过程简介

要了解 `wcgain_` 底层计算的具体过程，您可以通过以下几种方法来深入探究：

## 1. 查看 MATLAB 内部函数（如果可用）

```matlab
% 尝试查看函数代码（如果MATLAB允许）
type wcgain_
edit wcgain_

% 或者查看函数信息
which wcgain_
help wcgain_
```

## 2. 通过学术文献理解算法原理

`wcgain_` 的实现基于以下核心理论：

### 结构奇异值(μ)分析基础

```matlab
% 理论上的 μ 分析流程：
% 1. 将不确定系统转换为 LFT 形式
%   M = [M11 M12; M21 M22], Δ = diag(Δ1, Δ2, ..., Δn)
%   系统: F_u(M,Δ) = M22 + M21Δ(I - M11Δ)^{-1}M12

% 2. 计算结构奇异值
%   μ_Δ(M) = 1/min{σ(Δ) | det(I - MΔ) = 0, Δ ∈ Δ}
```

### 上界/下界算法原理

```matlab
% 上界计算（基于缩放方法）：
%   μ_Δ(M) ≤ inf_D σ(DMD^{-1})
%   其中 D 是与 Δ 结构兼容的缩放矩阵

% 下界计算（基于幂迭代）：
%   通过迭代寻找使系统不稳定的最小 Δ
%   μ_Δ(M) ≥ 1/σ(Δ_min)
```

## 3. 通过调试模式观察计算过程

```matlab
% 创建一个简单的测试系统来观察计算过程
delta = ultidyn('delta',[1 1],'Bound',0.5);
tau = ureal('tau',1,'Range',[0.8,1.2]);
G = tf(1,[tau 1]) * (1 + 0.1*delta);

% 设置详细输出选项
opts = wcOptions('Display','on','Sensitivity','on');

% 运行计算并观察输出
[wcg, wcu, info] = wcgain(G, opts);
```

## 4. 手动实现简化版本理解原理

```matlab
function [wcg_manual, info_manual] = manual_wcgain_approximation(usys, w)
    % 简化的 wcgain 实现，用于理解原理
    
    % 步骤1: 频率网格选择
    if nargin < 2
        w = logspace(-2, 2, 50);  % 默认频率范围
    end
    
    % 步骤2: 转换为 LFT 形式（简化）
    [M, Delta] = lftdata(usys);
    
    % 步骤3: 在频率点上计算 μ 边界
    lower_bounds = zeros(size(w));
    upper_bounds = zeros(size(w));
    worst_perturbations = cell(size(w));
    
    for i = 1:length(w)
        % 获取当前频率点的系统矩阵
        M_w = freqresp(M, w(i));
        
        % 简化的 μ 计算（实际算法更复杂）
        [mu_lower, mu_upper, delta_worst] = simplified_mu_calculation(M_w, Delta);
        
        lower_bounds(i) = mu_lower;
        upper_bounds(i) = mu_upper;
        worst_perturbations{i} = delta_worst;
    end
    
    % 步骤4: 找到最坏情况
    [max_lower, idx_max] = max(lower_bounds);
    
    % 构造输出结构
    wcg_manual.LowerBound = max_lower;
    wcg_manual.UpperBound = max(upper_bounds);
    wcg_manual.CriticalFrequency = w(idx_max);
    
    info_manual.Frequency = w;
    info_manual.Bounds = [lower_bounds(:), upper_bounds(:)];
    info_manual.WorstPerturbation = worst_perturbations{idx_max};
end

function [mu_lower, mu_upper, delta_worst] = simplified_mu_calculation(M, Delta)
    % 简化的 μ 计算（实际 wcgain_ 使用更复杂的算法）
    
    % 上界计算（基于缩放方法）
    mu_upper = compute_mu_upper_bound(M, Delta);
    
    % 下界计算（基于幂迭代等方法）
    [mu_lower, delta_worst] = compute_mu_lower_bound(M, Delta);
end
```

## 5. 通过相关函数理解算法

```matlab
% 研究相关的底层函数
help mussv        % 结构奇异值计算
help lftdata      % LFT 分解
help robstab      % 鲁棒稳定性分析
help wcsigma      % 最坏情况奇异值

% 查看这些函数的文档和示例
doc mussv
```

## 6. 学术参考资料

要深入理解算法，建议参考以下经典文献：

### 核心理论文献：
1. **Zhou, K., Doyle, J. C., & Glover, K.** (1996). *Robust and Optimal Control*
2. **Packard, A., & Doyle, J. C.** (1993). "The complex structured singular value"
3. **Balas, G. J., et al.** (2001). *μ-Analysis and Synthesis Toolbox*

### 关键算法步骤：

1. **LFT 建模**：
   ```matlab
   % 系统表示为: F_u(M, Δ) = M22 + M21Δ(I - M11Δ)⁻¹M12
   % 其中 Δ 包含所有不确定性块
   ```

2. **μ 上界计算**：
   - 使用 D-K 迭代或其他缩放方法
   - 寻找最优缩放矩阵 D
   - 计算 μ 上界: μ ≤ inf_D σ(DMD⁻¹)

3. **μ 下界计算**：
   - 使用幂迭代或广义特征值方法
   - 寻找使系统接近不稳定的 Δ
   - 计算 μ 下界: μ ≥ 1/σ(Δ_worst)

4. **频率扫描优化**：
   - 智能选择频率点
   - 在关键频率区域加密采样
   - 使用插值和外推技术

## 7. 实际调试技巧

```matlab
% 设置调试选项来观察计算过程
opts = wcOptions('Display','on',...
                 'MussvOptions','m5',...  % 详细输出
                 'Sensitivity','on');

% 运行计算并观察中间结果
[wcg, wcu, info] = wcgain(usys, opts);

% 分析返回的信息结构
disp('频率点:');
disp(info.Frequency);
disp('边界矩阵:');
disp(info.Bounds);
```

## 8. 理解不确定性处理

```matlab
% 观察系统如何处理不同类型的不确定性
delta_dyn = ultidyn('delta',[1 1]);      % 动态不确定性
a_real = ureal('a',1,'Range',[0.5,2]);   % 实参数不确定性

% 创建混合不确定性系统
G_mixed = tf(1,[1 a_real]) * (1 + 0.1*delta_dyn);

% 分析计算过程
[wcg_mixed, wcu_mixed, info_mixed] = wcgain(G_mixed);
```

通过以上方法，您可以深入理解 `wcgain_` 的底层计算过程。虽然无法直接查看 MATLAB 的专有实现代码，但通过理论分析、简化实现和相关函数的研究，可以掌握其核心算法原理。

**关键要点**：
- 基于结构奇异值(μ)理论
- 使用上界/下界算法保证结果可靠性  
- 通过 LFT 建模统一处理各类不确定性
- 采用智能频率扫描和优化技术

# wcgain 和 sigmaplot对比

在系统是SI或者SO的时候（即各频率上复矩阵奇异值分解后只有一个奇异值），wcgain得到的wcsigmaplot和 sigmaplot是不是一样的图像？



# V-C. Robust Fault Detection Filter Synthesis

通过wcgain.m函数找到\(\tilde{G}_{d}(s,\Delta)\)的上界传递函数，该函数在所有频率上对应最高增益的不确定性值。

为了演示工作原理，检查\(\tilde{G}_{d}(s,\Delta)\)的奇异值以验证wcgain.m是否能够找到一个传递函数矩阵\(\bar{G}_{d}(s)\)，使其能在所有\(\omega\)和\(\Delta\)下从上方界定这些奇异值。

下面这个图是多输入多输出的，因此会有最大和最小奇异值。

![image-20251110195056352](C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251110195056352.png)

## 我本质想要得到的是什么？是上图中红色的曲线\(\bar{G}_{d}(s)\)的每个奇异值曲线都在蓝色曲线\(\tilde{G}_{d}(s,\Delta)\)的各种不确定性情况下的曲线上方？是最大奇异值在其上方就可以了还是所有奇异值都要做到在其上方？



这个问题问得非常好，直接切入了鲁棒控制和故障诊断理论中的一个关键技术细节。

您的核心问题是：**对于多输入多输出 (MIMO) 系统，`wcgain.m` 找到的“最坏情况增益”（红线 $\bar{G}_{d}(s)$）与不确定系统（蓝线 $\tilde{G}_{d}(s,\Delta)$）的奇异值之间的关系是什么？**

答案是：**必须要求红线 $\bar{G}_{d}(s)$ 的所有奇异值（最大和最小奇异值）都位于蓝线 $\tilde{G}_{d}(s,\Delta)$ 的所有不确定性实例的所有奇异值（最大和最小奇异值）的**上方**。**

------



### 详细解释：为何是所有奇异值？



在鲁棒故障检测滤波器（FDF）的设计中，我们的目标是实现以下鲁棒性能约束：

$$\Vert R(s)\tilde{G}_d(s, \Delta)\Vert_{\infty} \le \gamma$$

其中：

* $R(s)$ 是待设计的后置滤波器。

* $\tilde{G}_d(s, \Delta)$ 是从非故障输入到预残差的**不确定闭环传递函数**。

* $\Vert \cdot \Vert_{\infty}$ 是 $H_{\infty}$ 范数，对于一个传递函数矩阵 $M(s)$，其定义为：

  

  $$\Vert M(s)\Vert_{\infty} = \sup_{\omega} \bar{\sigma}(M(j\omega))$$

  

  其中 $\bar{\sigma}$ 是最大奇异值 (Maximum Singular Value)。

* $\gamma$ 是容忍的扰动放大上界（在本论文中 $\gamma=1$）。



#### 1. 约束的等价转换



为了设计 $R(s)$，论文采用了一种基于**保守上界**的方法。这个方法的核心是找到一个**确定的**（不含 $\Delta$）的传递函数 $\bar{G}_d(s)$，使得：

$$\bar{\sigma}(\tilde{G}_d(j\omega, \Delta)) \le \bar{\sigma}(\bar{G}_d(j\omega)), \quad \forall \omega, \forall \Delta$$

如果能找到这样的 $\bar{G}_d(s)$，那么原始的鲁棒约束就可以被一个**更容易求解的标称约束**所取代：

$$\Vert R(s)\bar{G}_d(s)\Vert_{\infty} \le \gamma \quad \Rightarrow \quad \bar{\sigma}(R(j\omega)\bar{G}_d(j\omega)) \le \gamma, \quad \forall \omega$$

然后，通过优化方法（如 $H_{\infty}$ 优化），找到一个 $R(s)$ 使得 $\Vert R(s)\bar{G}_d(s)\Vert_{\infty} \le \gamma$ 成立，同时最大化故障传递增益 $\Vert R(s)\bar{G}_f(s)\Vert_{\infty}$。



#### 2. `wcgain.m` 找到的“最坏情况”



`wcgain.m` 函数（或等效的最坏情况增益计算工具）的目的是找到一个**不确定性实例 $\Delta^\*$**，使得**最大奇异值**在所有不确定性中达到最大值：

$$\bar{\sigma}(\tilde{G}_d(j\omega, \Delta^*)) = \sup_{\Delta} \bar{\sigma}(\tilde{G}_d(j\omega, \Delta))$$

`wcgain.m` 得到的红线 $\bar{G}_d(s)$ 就是对应于这个 $\Delta^*$ 的传递函数矩阵 $\tilde{G}_d(s, \Delta^*)$。

问题出现的地方：

对于 MIMO 系统，最大奇异值达到最大，并不意味着该矩阵的其他奇异值（例如最小奇异值）也高于所有其他不确定性实例 $\Delta$ 的对应奇异值。



#### 3. 论文中出现的问题（图 13）



* **图 13 (左图)**：
  * **蓝线 ($\tilde{G}_d(s, \Delta)$)**：代表了 50 个不同的不确定性 $\Delta$ 实例的**最大和最小奇异值**曲线。
  * **红线 ($\bar{G}_d(s)$)**：是 `wcgain.m` 找到的“最坏情况”对应的 $\tilde{G}_d(s, \Delta^*)$ 的**最大和最小奇异值**。
  * **观察**：在某些频率（特别是高频部分），红线的**最小奇异值**（红虚线）**低于**某些蓝线实例的**最小奇异值**（蓝虚线）。
* **结论**：这意味着红线 $\bar{G}_d(s)$ **不是**一个足够保守的上界。它只保证**其最大奇异值**在所有不确定性的最大奇异值上方（这是定义所致），但它**不能保证其所有奇异值**都包络住所有不确定性实例的所有奇异值。



#### 4. 解决方案：调谐权重



为了让 $\bar{G}_d(s)$ 成为一个有效的保守上界，必须满足：

$$\sigma_i(\tilde{G}_d(j\omega, \Delta)) \le \sigma_i(\bar{G}_d(j\omega)), \quad \forall i, \forall \omega, \forall \Delta$$

（其中 $\sigma_i$ 是第 $i$ 个奇异值。）

由于 `wcgain.m` 无法直接保证这一点，论文作者不得不引入**调谐权重滤波器 $\alpha(s)$ 和 $\beta(s)$**，通过迭代地、手动地“抬高” $\bar{G}_d(s)$ 的奇异值曲线，使其修正后的形式 $\bar{G}'_d(s)$ (图 13 中的黑-点划线) 最终能够**完全包络**所有蓝线的最大和最小奇异值。



### 总结



您想得到的本质是：**找到一个确定的传递函数 $\bar{G}_{d}(s)$，它在频域上必须是所有不确定性传递函数 $\tilde{G}_{d}(s,\Delta)$ 的**“严格上界”**。**

对于 MIMO 系统而言，这要求：

1. **最大奇异值必须被包络**（这是 `wcgain.m` 的直接输出）。
2. **所有其他奇异值（包括最小奇异值）也必须被包络**（这是 `wcgain.m` **无法保证**的，需要手动引入 $\alpha(s)$ 和 $\beta(s)$ 来修正，确保黑-点划线**始终位于**所有蓝线实例的上方）。

只有满足了**所有奇异值都被包络**这一更严格的条件，才能确保最终设计的滤波器 $R(s)$ 在面对任何不确定性时，其残差 $\epsilon$ 的 $H_{\infty}$ 范数都小于 $\gamma$，即鲁棒性能得到保证。

## 对论文中“V-C. Robust Fault Detection Filter Synthesis”部分的详细解释

好的，这是对论文中“V-C. 鲁棒故障检测滤波器综合 (Robust Fault Detection Filter Synthesis)”部分的详细解释。

[cite_start]本节是仿真案例研究的核心部分，其目的是**应用论文第四节 (Section IV-B) 中提出的理论，为自由浮动光罩台 (FFR) 系统设计一个鲁棒故障检测滤波器 (FDF)** [cite: 600]。

[cite_start]这个滤波器的目标是：在存在模型不确定性和扰动的情况下，依然能够最优地放大（凸显）可能发生的故障信号 [cite: 600]。

整个综合过程可以分解为以下几个关键步骤：

### 1. 综合的输入

为了开始设计，需要以下四个关键的动态模型：
1.  [cite_start]**不确定性被控对象模型 ($G_u$)**：来自 V-A 节，如图 10 所示 [cite: 601]。
2.  [cite_start]**扰动模型 ($G_d$)**：来自 V-A 节，如图 11 所示 [cite: 601]。
3.  [cite_start]**故障模型 ($G_f$)**：来自 V-A 节，如图 12 所示 [cite: 601]。
4.  [cite_start]**鲁棒反馈控制器 ($K$)**：来自 V-B 节，如图 23 所示 [cite: 601]。

### 2. 构造不确定性传递函数矩阵 (TFM)

[cite_start]FDF 设计的第一步是获取从“非故障”输入（即参考信号 $r$ 和扰动 $d$）到“预残差”($\tilde{\epsilon}$) 的闭环传递函数 [cite: 601]。

* [cite_start]**互质分解**：为了得到预残差，需要对标称模型 $G$ 进行左互质分解 (LCF) 得到 $[\tilde{M}_u \quad \tilde{N}_u]$ [cite: 602]。
* [cite_start]**简化**：由于 FFR 的标称模型 $G$ 被建模为稳定的，研究中采用了最简单的分解形式：$[\tilde{M}_u \quad \tilde{N}_u] = [I \quad G]$ [cite: 602]。
* [cite_start]**构造 $\tilde{G}_d(s, \Delta)$**：将所有模型组合起来，构建了一个 2x4 的不确定传递函数矩阵 $\tilde{G}_d(s, \Delta)$ [cite: 603]。
    * [cite_start]它有 **2 个输出** (因为 FFR 被解耦为 2x2 系统) [cite: 603]。
    * [cite_start]它有 **4 个输入** (2 个来自参考信号 $r$，2 个来自扰动 $d$) [cite: 603]。

### 3. 寻找并修正上界 $\bar{G}_d(s)$（核心挑战）

[cite_start]根据第四节 (Section IV-B) 的理论，需要找到一个**确定的（非不确定的）上界 $\bar{G}_d(s)$**，该上界必须“包络”住所有可能的不确定性 $\tilde{G}_d(s, \Delta)$ [cite: 603]。

* [cite_start]**寻找最坏情况**：研究中使用了 Matlab 的 `wcgain.m` 函数来寻找 $\tilde{G}_d(s, \Delta)$ 在所有频率上的“最坏情况增益”（即最高增益） [cite: 604][cite_start]。这个具有最高增益的特定传递函数被当作 $\bar{G}_d(s)$ [cite: 604, 605]。
* [cite_start]**发现问题**：通过图 13 的奇异值图（左图）发现，`wcgain.m` 找到的这个 $\bar{G}_d(s)$（图中红线）并**不能**保证在所有频率下*所有*的奇异值都高于 $\tilde{G}_d(s, \Delta)$（图中蓝线）[cite: 606, 608]。
* [cite_start]**后果**：如果不修正这个问题，直接使用这个 $\bar{G}_d(s)$ 来设计滤波器 $R$，最终的扰动抑制效果将**无法满足** $\gamma = 1$ 的约束条件 [cite: 608]。

### 4. 引入调谐权重进行修正

为了解决上述问题，研究人员必须手动修正 $\bar{G}_d(s)$：

* [cite_start]**引入权重**：引入了两个额外的调谐权重滤波器 $\alpha(s)$ 和 $\beta(s)$（如图 14 所示）[cite: 608]。
* [cite_start]**迭代调优**：通过一个迭代过程，手动调整这两个权重，将它们施加于 $\bar{G}_d(s)$，目的是“局部抬高” $\bar{G}_d(s)$ 的奇异值 [cite: 608, 609]。
* [cite_start]**最终上界**：这个过程一直持续到修正后的 $\bar{G}_d(s)$（如图 13 中的黑-点划线所示）能够完全包络住所有的不确定性，从而确保设计约束 $\Vert R(s)\tilde{G}_d(s, \Delta)\Vert_{\infty} \le \gamma$ 能够被满足 [cite: 608, 610]。

### 5. 综合后置滤波器 R 并评估

* [cite_start]**获得滤波器 R**：基于这个经过修正的、保守的 $\bar{G}_d(s)$，计算出了最终的后置滤波器 $R$ [cite: 611]。
* [cite_start]**子最优结果（Remark 17）**：论文明确指出，这个结果是**子最优 (sub-optimal)** 的 [cite: 611, 617][cite_start]。这是因为需要手动引入 $\alpha(s)$ 和 $\beta(s)$ 权重，导致 $\bar{G}_d(s)$ 是一个保守的（即“过高”的）上界 [cite: 611, 612][cite_start]。如果存在一个完美的、紧凑的上界，那么结果将是*最优*的 [cite: 612]。
* **滤波器对比（图 15）**：
    * [cite_start]图 15 展示了综合得到的鲁棒滤波器 $R$（实线）[cite: 613]。
    * [cite_start]同时，图中还展示了假设**没有模型不确定性**时的“标称最优滤波器”（虚线）[cite: 613, 614]。
    * [cite_start]两者形态差异巨大，这有力地证明了**鲁棒故障检测的必要性**——即必须考虑模型不确定性，否则标称滤波器在实际中会失效 [cite: 615]。

### 6. 频域验证

综合完成后，必须在频域中验证设计是否达标：

* **约束验证（图 16 左图）**：
    * [cite_start]此图展示了施加滤波器 $R$ 后，从“非故障”输入 $[r \quad d]$ 到残差 $\epsilon$ 的闭环传递（$T_{\epsilon\tilde{d}}$）[cite: 618]。
    * [cite_start]结果显示，所有奇异值（图中绘制了 50 种不确定性情况）都**低于** $\gamma = 1$ 的约束界限（虚线）[cite: 618, 624]。
    * [cite_start]**结论：设计达标，成功抑制了扰动和不确定性的影响。** [cite: 618]
* **性能验证（图 16 右图）**：
    * [cite_start]此图展示了从故障 $f$ 到残差 $\epsilon$ 的传递（$T_{\epsilon f}$），即**故障放大性能** [cite: 619, 622]。
    * **分析 (Remark 18)**：
        1.  [cite_start]**可检测性**：在 345 Hz（增益穿越 0 dB 的频率点）以下，故障都是可检测的 [cite: 624][cite_start]。这远高于 140 Hz 的控制带宽 [cite: 627]。
        2.  [cite_start]**放大倍数**：在控制带宽以下的故障，被放大了约 3 倍（9.5 dB），而扰动则被抑制 [cite: 628]。
        3.  [cite_start]**性能损失**：与“标称最优”情况（图中虚线）相比 [cite: 625][cite_start]，由于模型不确定性导致的故障检测性能下降（即放大倍数降低）非常小 [cite: 626, 629]。

### 7. 时域仿真验证

最后，通过时域仿真来展示 FDF 的实际效果（图 17）：

* **仿真设置**：
    * [cite_start]**扰动 ($d$)**：幅度为 [-0.1, 0.1] 的白噪声 [cite: 631]。
    * [cite_start]**参考 ($r$)**：幅度为 1 的 50 Hz 方波信号，在 T=0.05s 时施加 [cite: 632]。
    * [cite_start]**故障 ($f$)**：幅度为 1 的 12.5 Hz 信号，在 T=0.1s 时注入 [cite: 633]。
* **仿真结果（图 17）**：
    * [cite_start]该图显示了两个残差信号 $\epsilon_1$ 和 $\epsilon_2$（针对 30 种不同的不确定性）[cite: 634, 636]。
    * [cite_start]**关键发现**：由于我们知道输入 $r$ 和 $d$ 的幅值，并且设计中保证了 $\gamma=1$ 的抑制界限，因此可以在时域残差图上画出一条**绝对的“无故障”界限** [-1, 1] [cite: 635, 637]。
    * [cite_start]**T < 0.1s (无故障时)**：尽管系统在运动（有 $r$）且存在噪声（有 $d$），但所有的残差信号都**严格保持在 [-1, 1] 的界限内** [cite: 635, 640]。
    * [cite_start]**T > 0.1s (故障发生时)**：故障信号被 FDF 放大，导致残差信号**明显超出了** [-1, 1] 的界限 [cite: 638, 641]。
* **最终结论**：
    * [cite_start]这实现了一种“高度期望的情况” (highly desired situation) [cite: 639, 751]，即残差界限是确定的。
    * [cite_start]FDF 成功地提供了**故障与无故障情况之间的清晰区分** [cite: 53, 639, 730]，无论模型不确定性如何变化，都能有效避免误报。
    * [cite_start]（论文还提到，即使 $\epsilon_1$ 没有在所有情况下都超限，但 $\epsilon_2$ 明显超限，这对于故障检测来说已经足够了 [cite: 642, 643]。）



# V-D. Discussion

## 必需：对象G的最小阶模型：黎卡提

为了避免高阶传递函数作为黎卡提方程的输入可能导致数值不稳定，我们非常需要对象G的最小阶模型。可以看出，如果G是非最小阶的，那么得到的闭环传递函数会包含非常接近虚轴的不稳定右半平面极点，这会给寻找最坏情况增益传递带来问题。除此之外，对于运动系统，建议使用对象的模态模型来获得最小阶模型，并能够将系统建模到所需的模态。

## 系统含纯积分器会导致低频范围数值不稳定

如附录B-A所示，该系统已被建模为稳定系统，而非使用纯积分器。这样做是为了防止在极低频范围内出现数值不稳定性。如果真实系统包含纯积分器，那么在1.6e-3 Hz的积分器截止频率以下，估计模型与真实系统之间会出现失配。这种失配会增加低频模型的不确定性，并转化为从$r$、$d$到$\epsilon$的不同闭环传递函数，可能导致仅在低频范围内不满足$\gamma$边界条件。如果输入信号$r$和/或$d$包含极低频分量，这种失配可能会导致残差信号在很长一段时间内漂移出$\gamma$边界。克服这种影响的最简单方法是在极低频范围内通过增加增益来调整成形权值$\alpha(s)$和/或$\beta(s)$，从而降低后置滤波器的增益，进而消除这种不良影响。

必须提及的是，图17中的曲线是使用不稳定系统G绘制的，即采用纯积分器，而非用于后置滤波器综合的带偏移积分器的模型。

## 10Hz低频后测量可靠

若综合滤波器需在实际应用中实现，由于10 Hz后的对象测量是可靠的，不确定对象Gu应在10 Hz前包含更多不确定性。

## 原论文

![image-20251111094549503](C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251111094549503.png)



































# Bode图和Sigma图在显示MIMO系统时的区别

1. 对比如下

2. Bode图：对于MIMO系统，Bode图会为每个输入输出对绘制一对幅频和相频图。例如，一个2输入2输出的系统，Bode图会生成4个幅频图和4个相频图（通常以子图形式排列）。

   * **显示每个输入输出通道的频率响应**
   * 对于MIMO系统，显示所有I/O对的幅频和相频特性
   * 产生多个子图：每个输入→输出通道一对图

   ```matlab
   figure
   bode(G2d, Bodeoption);
   % Bode图输出示例：
   % 会生成 4 个子图：
   % - 子图1: 输入1 → 输出1 的幅频特性
   % - 子图2: 输入1 → 输出1 的相频特性  
   % - 子图3: 输入1 → 输出2 的幅频特性
   % - 子图4: 输入1 → 输出2 的相频特性
   % - 子图5: 输入2 → 输出1 的幅频特性
   % - 子图6: 输入2 → 输出1 的相频特性
   % - 子图7: 输入2 → 输出2 的幅频特性
   % - 子图8: 输入2 → 输出2 的相频特性
   ```

3. Sigma图：Sigma图绘制的是系统在所有频率点的奇异值。对于MIMO系统，每个频率点有多个奇异值（等于min(输入数,输出数)），Sigma图会将所有奇异值绘制在同一张图上，用不同的颜色表示。

   * **显示系统的奇异值（增益特性）**
   * 对于MIMO系统，显示最大/最小增益方向
   * 只产生一个图：系统在所有方向上的增益范围

   ```matlab
   figure
   sigma(G2d, logspace(-2, 3, 200));
   % Sigma图输出：
   % 只生成 1 个图，包含多条曲线：
   % - 曲线1: 最大奇异值 (系统最大增益方向)
   % - 曲线2: 最小奇异值 (系统最小增益方向)
   % - 可能还有其他奇异值曲线
   ```

因此，对于同一个MIMO系统，Bode图会产生多个子图（每个通道一个），而Sigma图只有一个图，但包含多条曲线（每个奇异值一条）。

## 奇异值图到底代表什么含义，为什么只有一个子图（不过也包含多条曲线）

`sigma` 图是**频率响应**的推广。它描绘的是**奇异值随频率变化的曲线**。（SI或者SO系统就只有一条曲线，最大奇异值和最小奇异值一样）

* 对于每一个频率点 `ω`，我们计算复数矩阵 `G(jω)`。
* 对这个矩阵进行奇异值分解，得到一组奇异值 `σ₁(jω), σ₂(jω), ..., σₖ(jω)`。
* 然后，我们在图上为每一个 `i` 画出 `σ_i(ω)` 随频率 `ω` 变化的曲线。

因此：

* **最上面的曲线**是 `σ₁(ω)`，它表示在整个频率范围内，**所有输入方向中可能的最大增益**。

  

## 重要理解：对标称系统和不确定性系统画sigma图

**我理解的：由于不同频率点的复矩阵不同，那么奇异值分解的奇异向量方向就不同，所以就算是最大奇异值σ_1(ω)，其实也是不同奇异向量方向上的，而且比如ω1的所有奇异向量和ω2的所有奇异向量其实不是一一对应的，只是都取了最大奇异值，所以组成了最大奇异值曲线，同理最小奇异值曲线。而中间的奇异值曲线其实意义不大。**

**所以对于一个标称系统，进行`sigma(G_nominal, w);`得到的奇异值曲线其实就是最大奇异值曲线，也就是对每个频率的复矩阵进行奇异值分解，然后每个频率上取最大值，连成一条线。**

**对于不确定性系统，进行`sigma(G2d, w);`，实际上就是对每个取不同不确定性值的系统矩阵，再进行上述标称系统的处理，然后画在一个图里。每条曲线代表的是不同的不确定性值。**

deepseek的回复：

1. **不同频率，不同方向**
   * 在每个频率点 `ω`，我们计算的是不同的复数矩阵 `G(jω)`
   * 每个矩阵都有自己独特的奇异值分解：`G(jω) = U(ω)Σ(ω)V^H(ω)`
   * 因此，**最大奇异值 σ₁(ω₁) 对应的输入方向 v₁(ω₁)** 和 **σ₁(ω₂) 对应的输入方向 v₁(ω₂)** 可能是完全不同的方向
   * 这就是为什么我们说"最大增益曲线"实际上是由不同方向上的增益组成的
2. **曲线是"冠军曲线"，不是"选手曲线"**
   * 最大奇异值曲线回答的是："在频率 ω 下，**存在**某个输入方向能获得多大的最大增益？"
   * 它**不**回答："沿着某个固定输入输出方向，增益随频率如何变化？"
   * 后者需要用特定的输入方向分析（如特征增益轨迹）

**奇异值的数量 = min(输出数, 输入数)**

```matlab
% 对于任意 MIMO 系统 G(s)，在频率点 ω 处：
% G(jω) ∈ C^(m×n)，其中 m=输出数，n=输入数

% 奇异值分解：G(jω) = UΣV*
% 其中：
% - U ∈ C^(m×m)：输出方向矩阵（酉矩阵）
% - V ∈ C^(n×n)：输入方向矩阵（酉矩阵）  
% - Σ ∈ R^(m×n)：奇异值矩阵（对角，元素为 σ₁ ≥ σ₂ ≥ ... ≥ σₙ ≥ 0）



% 画图
    figure
% 1. 标称系统 Sigma 图
    subplot(1,2,1);
    sigma(G_nominal, w);
    title('标称系统 Sigma 图');
    grid on;
    legend('σ₁ (最大奇异值)', 'σ₂ (最小奇异值)');
    
% 2. 不确定性系统 Sigma 包络
    subplot(1,2,2);
    sigma(G2d, w);
    title('不确定性系统 Sigma 包络');
    grid on;
```

![image-20251110202734469](C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251110202734469.png)



# 我们需要\(\bar{G}(s)\)的所有奇异值都是 $\tilde{G}_{d}(s,\Delta)$ 的所有不确定性实例的所有奇异值的上界，但其实也不是很合理（用图形包络更合理）

## 历史上最清楚说明：

想象三维椭球，假如有三个轴xyz，在某一确定的频率下\(\bar{G}(j\omega_{i})\)是一个确定形状大小的椭球；在某一确定频率下，$\tilde{G}_{d}(j\omega_{i},\Delta)$ 是随着\(\Delta\)变化而伸缩轴长度的椭球，甚至于还会旋转（因为不同的矩阵，奇异值分解之后奇异向量可能都不一样，所以轴的方向可能都不一样）。

我们想要的是，在每个频率下，都有\(\bar{G}(j\omega_{i})\)完全包络住$\tilde{G}_{d}(j\omega,\Delta)$ ，无论\(\Delta\)怎么变化。

所以只要求最大奇异值上界（\(\bar{G}(s)\)的最大奇异值都是 $\tilde{G}_{d}(s,\Delta)$ 的所有不确定性实例的所有最大奇异值的上界）是不合理的。

我们需要\(\bar{G}(s)\)的所有奇异值都是 $\tilde{G}_{d}(s,\Delta)$ 的所有不确定性实例的所有奇异值的上界，但其实也不是很合理，因为存在不确定性导致的旋转，\(\bar{G}(j\omega_{i})\)的轴（奇异向量方向）和\(\tilde{G}_{d}(j\omega,\Delta)\)轴之间不一定，或者说肯定不会完全同向。甚至于看最大奇异值在数学上来说都是没那么好的，因为你的最大奇异值方向和我的最大奇异值方向又不一定一样，所以使你的最大奇异值比我的最大奇异值大也不能保证我的最大奇异值不会从其他方向穿模出去。

## 2023依肯罗斯的解决方法是：

使椭球变成球（上界），把奇异值都弄成一样的，都是最大奇异值，这样就保证了一定是上界，一定是包络。仔细来说就是：要得到这么一个\(\bar{G}(s)\)，这个\(\bar{G}(s)\)满足下列条件：对某个频率上的\(\bar{G}(j\omega_{i})\)进行奇异值分解，其各个奇异值大小都是相同的，而且都是大于等于$\tilde{G}_{d}(j\omega_{i},\Delta)$的最大奇异值的

![image-20251111084721551](C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251111084721551.png)

### 或者进一步的，找一个自动检查算法，检查是否所有频率都满足（42）上界条件，如果不满足，指导如何调整\(\alpha(s)\)和\(\beta\)来满足

![image-20251111085721299](C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251111085721299.png)

### 目前的解决方法：使椭球变成球

使椭球变成球（上界），把奇异值都弄成一样的，都是最大奇异值，这样就保证了一定是上界，一定是包络。仔细来说就是：要得到这么一个\(\bar{G}(s)\)，这个\(\bar{G}(s)\)满足下列条件：对某个频率上的\(\bar{G}(j\omega_{i})\)进行奇异值分解，其各个奇异值大小都是相同的，而且都是大于等于$\tilde{G}_{d}(j\omega_{i},\Delta)$的最大奇异值的。

目前，已开发出一种不受系统输出数量\(n_y\)限制的保守方法，该方法满足问题(2)中的设计约束。上界实现\(\bar{G}_d(s)\)的构建仅通过补偿\(\tilde{G}_d(s, \Delta)\)的最大奇异值，即\(\sigma_1(\tilde{G}_d(s, \Delta))\)来完成，从而得到具有相等奇异值的对角后置滤波器。这一概念可与图8相关联，其中（<span style="color:#FF0000;">-</span>）中的上界是一个圆而非捕获所有灰色椭圆的椭圆。该方法在**第VI-B节**中进行了详细阐述，并已在具有4个输出的机电系统上付诸实践。

疑问：那你第五节怎么仿真出来的呢？只是最大和最小奇异值满足？

![image-20251111090103176](C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251111090103176.png)

# wcgain是如何得到上界的？

# 通过wcgain得到的也只是最大奇异值上界，因此不完全符合包络要求

wcgain得到的也只是最大奇异值上界，并不满足所有要求

这个问题深入到了 $\mu$ 综合和鲁棒分析的技术细节。`wcgain.m` 函数是 MATLAB 鲁棒控制工具箱（Robust Control Toolbox）中的一个核心工具，用于计算不确定性系统的**最坏情况增益**。

以下是关于 `wcgain.m` 如何得到上界的详细解释，以及一个简化的示例代码。

------



## `wcgain.m` 的工作原理



**`wcgain.m` 的目标是找到不确定性传递函数 $\tilde{G}_d(s, \Delta)$ 在所有可能不确定性 $\Delta$ 下的最大 $H_{\infty}$ 范数，并识别出导致该最大值的最坏情况不确定性值 $\Delta^*$。**<span style="color:#FF0000;">重要</span>



### 1. **数学基础：结构奇异值 ($\mu$) 理论**（可略）



`wcgain.m` 的计算基于**结构奇异值**（Structured Singular Value, $\mu$）理论。

对于一个包含 LTI 不确定性的线性分数变换（LFT）系统 $\tilde{G}_d(s, \Delta)$，其 $H_{\infty}$ 范数的上界可以通过以下关系式计算：

$$\sup_{\Delta} \Vert \tilde{G}_d(s, \Delta) \Vert_{\infty} = \sup_{\omega} \sup_{\Delta} \bar{\sigma}(\tilde{G}_d(j\omega, \Delta))$$

`wcgain.m` 实际上是在每个频率点 $\omega$ 上计算 $\mu$ 的上界，因为 $\mu$ 和最坏情况增益之间存在关系：

$$\sup_{\Delta} \bar{\sigma}(\tilde{G}_d(j\omega, \Delta)) \le \min_{D \in \mathcal{D}, d \ge 0} \bar{\sigma}\left(D \tilde{G}_d(j\omega) D^{-1}\right)$$

其中 $\tilde{G}_d(j\omega)$ 是不含不确定性的 LFT 上层矩阵，而 $D$ 和 $d$ 是用于 $\mu$ 综合的对角权重矩阵。



### 2. **计算流程**（可略）



`wcgain.m` 函数执行以下步骤来计算最坏情况增益和对应的 $\Delta^*$：

1. **构造广义被控对象 (LFT)**：用户必须首先使用 `uss` (不确定状态空间) 或 `ultidyn` (不确定 LTI 动态) 对象来定义不确定性模型 $\tilde{G}_d(s, \Delta)$。工具箱会将这个不确定系统表示为一个标准 LFT 形式，其中一个确定的 LTI 矩阵 $M$ 与不确定性块 $\Delta$ 相连。
2. **选择频率网格**：函数选择一个密集的频率网格 $\omega$（通常由用户指定或自动生成）。
3. **迭代计算 $\mu$ 上界**：在网格上的每个频率点 $j\omega$：
   * 计算矩阵 $M(j\omega)$。
   * 使用一个迭代优化算法（基于 $D-K$ 迭代或等效算法）来计算结构奇异值 $\mu_{\Delta}(M(j\omega))$ 的上界。这个 $\mu$ 的上界就是该频率下的最坏情况增益 $\bar{\sigma}(\tilde{G}_d(j\omega, \Delta))$。
   * **同时**，找到导致该最大增益的**最坏情况不确定性值 $\Delta^\*(j\omega)$**。
4. **构建 $\bar{G}_{d}(s)$**：$\bar{G}_{d}(s)$ 并不是一个单一的传递函数，而是由所有频率点上的最坏情况增益值构成的**增益包络线**。
5. **输出最坏情况传递函数**：函数返回一个特殊的输出结构（通常是一个状态空间模型），这个模型 $\bar{G}_{d}(s)$ 是将**整个频带上所有 $\Delta^\*(j\omega)$ 的幅值和相位连接起来**所对应的那个确定的传递函数。**在每个频率点 $j\omega$，$\bar{G}_{d}(j\omega)$ 的最大奇异值等于该频率下 $\tilde{G}_d(j\omega, \Delta)$ 的最大增益。**



### 3. **输出的 $\bar{G}_{d}(s)$ 的意义**（<span style="color:#FF0000;">重要</span>）



`wcgain.m` 返回的最坏情况传递函数 $\bar{G}_{d}(s)$（论文图 13 中的**红线**）具有以下特性：

* **最大奇异值包络**：在每个频率点 $\omega$ 上，$\bar{\sigma}(\bar{G}_{d}(j\omega))$ **等于** $\sup_{\Delta} \bar{\sigma}(\tilde{G}_d(j\omega, \Delta))$。
* **不保证所有奇异值包络**：**它不保证** $\bar{G}_{d}(j\omega)$ 的所有奇异值 $\sigma_i(\bar{G}_{d}(j\omega))$ 都能包络住所有 $\Delta$ 实例的相应奇异值 $\sigma_i(\tilde{G}_d(j\omega, \Delta))$。

这正是论文中遇到的问题：`wcgain.m` 找到了**增益最高的那个 $\Delta^\*$ 实例**，但这个实例的**最小奇异值**或者其他奇异值或者旋转后奇异值可能低于其他 $\Delta$ 实例的最小奇异值，导致它无法成为一个**严格的上界传递函数**。

------



## MATLAB 示例代码（简化，不重要）



假设我们有一个简单的不确定性系统 $G_{2d}$，它有 1 个输入 1 个输出，包含一个乘性不确定性 $\delta$。

$$G_{2d}(s, \delta) = \frac{1}{s+1} (1 + 0.5 \delta W(s))$$

其中 $\delta$ 是有界范数的动态不确定性 $\|\delta\|_{\infty} \le 1$， $W(s)$ 是不确定性权重。

Matlab

```
% 1. 定义不确定性块
% 假设 delta 是一个 LTI 动态不确定性，范数小于等于 1
delta = ultidyn('delta', [1 1], 'Bound', 1); 

% 2. 定义不确定性权重 W(s)
% W(s) 决定了不确定性随频率的分布
W = tf([0.5], [0.01 1]); 

% 3. 定义标称模型 G_nom
G_nom = tf(1, [1 1]);

% 4. 构造不确定性传递函数 G2d (LFT形式)
% G2d(s, delta) = G_nom * (1 + delta * W)
% 这是一个 1 输入 1 输出 (1x1) 的不确定系统
G2d = G_nom * (1 + delta * W);

% 5. 使用 wcgain.m 计算最坏情况增益

% 定义一个频率范围用于计算（可选，不指定则自动选择）
freq = logspace(-2, 2, 100); 

% 调用 wcgain
% [wc_gain, wc_freq, wc_info] = wcgain(G2d, freq);
[wc_gain, wc_freq, wc_info] = wcgain(G2d, 'VaryFrequency', freq); 

% wc_gain: 最坏情况增益（标量值，即sup_omega ||G2d||_inf）
% wc_freq: 发生最坏情况增益的频率

% 6. 提取最坏情况传递函数 (Gbar)

% wc_info 结构体中包含了导致最坏情况增益的 delta 值 (wc_info.Bounds.delta)
% 并且可以直接提取出最坏情况下的传递函数 Gbar (即论文中的 \bar{G}_{d}(s))
Gbar_ss = wc_info.WorstNominal; % 这是导致最坏增益的那个确定的状态空间模型 \tilde{G}_{d}(s, \Delta^*)

% 7. 绘制结果进行验证（MIMO系统需要奇异值）

% 绘制多个随机不确定性实例的奇异值曲线（仅用于验证）
n_samples = 20;
S = usample(G2d, n_samples); % 随机采样 20 个不确定性实例
figure;
bodemag(S, Gbar_ss, G_nom, freq); 
legend('Random samples (S)', 'Worst-case Nominal (\bar{G}_d)', 'Nominal G_{2d}', 'Location', 'SouthWest');
grid on;

% 在这个 1x1 示例中，最大奇异值就是增益本身。
% 在 MIMO 案例中，Gbar_ss 的最大奇异值曲线（红线）将正好等于 wc_info.Bounds.Gain 的曲线。
% 需要手动检查 Gbar_ss 的最小奇异值是否在其他随机样本的最小奇异值之上。

% 如果 G2d 是 MIMO (例如 2x2)，你需要绘制 Gbar_ss 的所有奇异值。
% bodemag 会自动绘制最大和最小奇异值。
```



### 总结要点



1. `wcgain.m` 基于 **$\mu$ 理论**，找到的是 **$H_{\infty}$ 范数（即最大奇异值）的包络线**。
2. 它返回的 $\bar{G}_{d}(s)$ 模型是**导致该包络线的最坏情况 $\Delta^\*$ 实例**。
3. 对于 **MIMO 系统**，这个 $\bar{G}_{d}(s)$ **不保证其所有奇异值**都包络住所有 $\Delta$ 实例的所有奇异值。
4. 论文中正是因为第 3 点的失效，才不得不引入额外的 $\alpha(s)$ 和 $\beta(s)$ 权重，**手动将 $\bar{G}_{d}(s)$ 的所有奇异值上移**，以确保它成为一个足够保守的**严格上界传递函数**，从而保证鲁棒 FDF 设计的有效性。



# MIMO系统的H∞范数为其最大奇异值。 

%使用sigma函数计算传递函数H的奇异值,max函数取奇异值的最大值即为传递函数H的无穷范数。

在 Bode 图上，H 无穷范数对应于幅度曲线的最大值，即幅频响应的最大增益。而在 Nyquist 图上，H 无穷范数对应于曲线的最大值，即 Nyquist 图中曲线到原点的最大距离。因此，H 无穷范数可以在 Bode 图和 Nyquist 图上进行直观的观察和分析。一般来说，当 H 无穷范数较大时，系统的稳定性可能会受到威胁，因此需要采取措施来确保系统的稳定性。
------------------------------------------------
# 最坏增益求不出来的原因-Gemini

## 指令（上传了2023依肯罗斯论文）

仔细分析论文中是否给出了解决方法？比如LFT等，能够解释并解决下列代码中报错？
下列代码：

```matlab
% 右边折叠了
clear;
clc;
close;
Bodeoption = bodeoptions;
Bodeoption.Grid = 'on';
Bodeoption.XLim = {[0.01 1000]};
Bodeoption.FreqUnits='Hz';
so = sigmaoptions;
so.FreqUnits = 'Hz';
%% 
a = ureal('a',0);
% a = -1.15;
 % a = -1;
Gu0 = tf(1,[1 2]);
Gu = tf(1,[1 2+a]);
Gd = tf([1 1],[1 2+a]);
Gf = tf(15,[1 2+a]);
G2u = Gu - Gu0;
K = tf([1 0.2*pi],[1 0]);
S = (eye(1) + Gu*K)^(-1);
% [fact,M,N] = lncf(Gu0);
% M = tf(M);
% N = tf(N);
M = 1;
N = tf(1,[1 2]);
Tr = M*G2u*K*(eye(1)-S*Gu*K);
Td = M*(Gd - G2u*K*S*Gd);
Tf = M*(Gf - G2u*K*S*Gf);
G2d = [Tr Td];
Ss = G2d*G2d';
[z,k,p] = zpkdata(Ss);
figure;
bode(Ss);
[wcg,wcu,info] = wcgain(G2d,{0.01,1000});
    

    % 3. 创建最坏情况系统，但是不知道为什么wcu是0（可能是因为代入第一个值，即a=0的时候就已经无穷了），所以导致最坏情况和标称系统得到的是一样的，都是a=0。
    G_worst = usubs(G2d, wcu);
    % G_nominal = usubs(G2d, []);
    G_nominal = G2d.NominalValue;  % 直接获取标称值
      w={0.01,1000};
    figure
    % 4. 对比绘图
    % subplot(2,2,2);
    % sigma(G_nominal); hold on;
    % sigma(G_worst);
    % sigma(G2d);
      
    sigmaplot(G_nominal,'r--',G_worst,'b--',w,so);
    legend('G_nominal','G_worst');

% [sv,wout] = sigma(Qcl*M*G2d);
figure
bode(G2d,Bodeoption);
figure
sigma(G2d, logspace(-2, 3, 200));

% 画图
    figure
% 1. 标称系统 Sigma 图
    subplot(2,2,1);
    sigma(G_nominal, w);
    title('标称系统 Sigma 图');
    grid on;
    legend('σ₁ (最大奇异值)', 'σ₂ (最小奇异值)');
    

    % 2. 不确定性系统 Sigma 包络
    subplot(2,2,2);
    sigma(G2d, w);
    title('不确定性系统 Sigma 包络');
    grid on;
    
    % 3. 采样系统显示
    subplot(2,2,3);
    G_samples = usample(G2d, 10);  % 采样10个系统
    sigma(G_samples, w);
    title('随机采样系统');
    grid on;
    
    % 4. 最坏情况分析
    subplot(2,2,4);
    [wcg, wcu, info] = wcgain(G2d, w);
    wcsigmaplot(G2d, w);
    title('最坏情况 Sigma 分析');
    grid on;


```

有以下报错：

```matlab
位置: main (第 147 行) 
错误使用 DynamicSystem/wcsigmaplot
System is not robustly stable for the specified uncertainty level (worst-case gain is infinite).
Use WCSIGMAPLOT(UFRD(SYS,FGRID)) to analyze gain variations in unstable or marginally stable systems.

出错 main (第 165 行)
    wcsigmaplot(G2d, w);
```

## 解决方法

这是一个非常好的问题，它触及了鲁棒控制理论与实际MATLAB应用相结合时的核心难点。

您遇到的报错`System is not robustly stable... (worst-case gain is infinite)`是**完全正确**的，而**问题恰好出在您的控制器`K`的定义上**。

**论文中不仅解释了这个问题，也提供了解决方案**，尽管它出现在了后面案例（V-D节）的讨论中。

------



### 错误的根源：`K`中的纯积分器



您的控制器定义为：

Matlab

```
K = tf([1 0.2*pi],[1 0]);
```

这个控制器在`s=0`处有一个**纯积分器**（即极点在原点）。

您构建的广义被控对象`G2d`，是`[Tr Td]`，它代表了从`[r d]`到预残差`~epsilon`的传递函数。根据您的代码，这个`G2d`的表达式中包含了`K`：

* `Tr = M*G2u*K*(eye(1)-S*Gu*K)`
* `Td = M*(Gd - G2u*K*S*Gd)`

由于`G2d`的传递函数中（显式或隐式地）包含了`K`的极点，**因此`G2d`系统本身在`s=0`处是边缘稳定的（marginally stable）**。



#### 为什么这会导致`wcgain`报错？



1. 

   **H-infinity (H∞) 范数的定义**：`wcgain`和`wcsigmaplot`是基于$\mathcal{H}*{\infty}$范数（H-infinity norm）的工具 [cite: 458][cite\_start]。$\mathcal{H}*{\infty}$范数被定义为一个系统在**所有频率**上的**最大奇异值（增益）** 1。

   

   

2. **积分器的增益**：一个纯积分器（`1/s`）在频率$\omega \to 0$时，其增益$|1/(j\omega)| \to \infty$。

3. **系统增益无穷大**：由于您的系统`G2d`在`s=0`处有一个极点，它在**0 Hz**处的增益是**无穷大**的。

4. **`wcgain`的结果**：`wcgain(G2d)`的任务是计算`G2d`在所有频率和所有不确定性`a`下的最大增益。由于`G2d`（即使在标称值`a=0`时）在0 Hz处增益已经为无穷大，`wcgain`正确地计算出`wcg = Inf`。

5. **`wcsigmaplot`的报错**：`wcsigmaplot`函数接收到这个无穷大的增益，于是停止并报告“系统不是鲁棒稳定的（最坏情况增益为无穷大）”。

> **对您注释的解释**：您在代码中猜测`wcu`是0（标称值）“可能是因为代入第一个值，即a=0的时候就已经无穷了”——**您的这个猜测完全正确**。系统在`a=0`时（标称系统）就已经因为积分器而具有无穷增益，`wcgain`无需寻找“最坏”的`a`，在标称点就已经失败了。

------



### 论文中的解决方案



您的代码完美复现了论文**第三节-E (III-E) 的“激励示例”（Motivating Example）** 2222。论文作者在实现该示例时，也必然会遇到这个积分器问题。



尽管论文在III-E节中没有明说如何处理，但在**第五节-D (V-D) 的“讨论”**（针对另一个案例）中，作者明确地阐述了这个问题和解决方案：

> \* “系统被建模为一个**稳定系统**，**而不是使用纯积分器**..." 3* "这样做是为了**防止在极低频（VLF）范围内出现数值不稳定性**。" 4

这正是您遇到的问题。`wcgain`在极低频（0 Hz）处遇到了数值无穷大。

**解决方案**：将纯积分器`s=0`替换为一个**具有非常小（但非零）极点的稳定近似**。即将`s`替换为`s + epsilon`（例如 `epsilon = 1e-6`）。

------



###  <span style="color:#FF0000;">修正后的代码（牛逼）</span>



要解决这个报错，请将您的控制器`K`的定义修改为：

Matlab

```
% 原始定义 (在 s=0 有极点)
% K = tf([1 0.2*pi],[1 0]); 

% 修正后的定义 (在 s=-1e-6 有极点，是稳定的)
epsilon = 1e-6; 
K = tf([1 0.2*pi],[1 epsilon]); 
```

**进行此项修改后：**

1. 系统`G2d`现在是**严格稳定**的（所有极点都在左半平面）。
2. `G2d`在0 Hz处的增益是有限的（尽管非常大）。
3. `wcgain`现在可以计算出一个**有限**的最坏情况增益`wcg`。
4. `wcsigmaplot`将能够成功绘制出有意义的奇异值包络线。

![image-20251111095650866](C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251111095650866.png)

### 关于LFT (线性分数阶变换)



您提到了LFT。您在MATLAB中执行的操作**正是**基于LFT的：

1. 

   **定义不确定性**：`a = ureal('a',0)` 创建了一个不确定原子`a` 5。

   

   

2. **构造不确定系统**：当您执行 `Gu = tf(1,[1 2+a]);` 和后续的闭环计算（如`G2d = [Tr Td];`）时，MATLAB**自动**在内部将这些表达式构建为一个**不确定的状态空间（`uss`）对象**。

3. 

   **`uss`对象**：`uss`对象**就是**系统`G2d`的LFT表示 6666。它内部存储了确定的LTI部分（`M`）和不确定性块（`Delta`，即`a`）。

   

   

4. **`wcgain`的调用**：`wcgain(G2d, ...)` 正是运行在`G2d`这个LFT表示上的$\mu$分析算法。



**总结**：您**已经在使用LFT**了。您遇到的问题不是LFT方法论的问题，而是您提供给LFT分析的系统`G2d`因包含纯积分器而**不满足H-infinity范数有限的基本假设**。上述的“稳定近似”7是解决此问题的标准工程实践。

## 论文中的讨论：通过在 $a = 0.01$ rad/s 处切断积分器来建模为稳定的

​	论文明确指出，模型是**“通过在 $a = 0.01$ rad/s 处切断积分器来建模为稳定的”**。

* **解释**：这意味着真实的 FFR 系统（作为运动系统）具有纯积分器（即极点在 $s=0$）。为了在数值计算中（特别是鲁棒控制工具箱）避免因 $s=0$ 处的无穷增益而导致的数值不稳定性，作者故意将极点从 $s=0$ 移动到了 $s = -a = -0.01$ rad/s 处，使其成为一个（非常慢的）稳定系统。

### 图片一：附录B, A. FFR 系统辨识

这张图片来自论文的 **“附录B：数值案例研究”** 中的 **“A. FFR 系统辨识”** 章节。

本节详细说明了如何构建用于仿真案例的**不确定性被控对象模型 $G_u$**。

1. **不确定性模型 $G_u$ 的构造**：
   * 不确定性模型 $G_u$ 是通过一个基础的状态空间模型 $\hat{G}_u$ 结合一个不确定性结构来定义的。
   * 公式为：$G_u = \hat{G}_u (I_2 + \frac{1}{10}\Delta W I_2)$。
   * 这里的 $W$ 是一个动态权重（见下文），$\Delta$ 是不确定性模块，而 $\hat{G}_u$ 是系统的状态空间实现。
2. **状态空间实现 $\hat{G}_u$**：
   * $\hat{G}_u$ 以 $\begin{bmatrix} A & B \\ C & D \end{bmatrix}$ 的形式给出。
   * 这是一个复杂的 8 阶模型（从 $A$ 矩阵的 8x8 维度可以看出），它有 2 个输入（$B$ 矩阵的 8x2 维度）和 2 个输出（$C$ 矩阵的 2x8 维度）。
   * $A$ 矩阵（系统动力学）中包含了三个不确定性参数：$m_1$, $k_1$, $k_2$。
3. **不确定性参数**：
   * 论文列出了三个参数的标称值及其不确定性范围：
     * $m_1 = 1 \pm 0.05$
     * $k_1 = 1.24\text{e}3 \pm 0.124\text{e}3$
     * $k_2 = 37.65 \pm 0.377$
4. **积分器的处理（关键点）**：
   * $A$ 矩阵的对角线（前四行）上出现了参数 $-a$。
   * 论文明确指出，模型是**“通过在 $a = 0.01$ rad/s 处切断积分器来建模为稳定的”**。
   * **解释**：这意味着真实的 FFR 系统（作为运动系统）具有纯积分器（即极点在 $s=0$）。为了在数值计算中（特别是鲁棒控制工具箱）避免因 $s=0$ 处的无穷增益而导致的数值不稳定性，作者故意将极点从 $s=0$ 移动到了 $s = -a = -0.01$ rad/s 处，使其成为一个（非常慢的）稳定系统。
5. **动态权重 $W$**：
   * $W$ 是一个传递函数，用于对不确定性 $\Delta$ 进行频率塑形。
   * $W = \frac{5623s^2}{s^2 + 1.01\text{e}6s + 1.26\text{e}10}$。
6. **标称模型 $G$**：
   * 标称模型 $G$（即没有不确定性的模型）是通过在 $\hat{G}_u$ 中使用参数的标称值（$m_1=1$, $k_1=1.24\text{e}3$, $k_2=37.65$）得到的。

------



### 图片二：D. 讨论



这张图片是论文的 **“D. 讨论”** 章节，它总结了在进行滤波器综合（设计）过程中遇到的**主要问题和经验教训**。

1. **关于最小阶模型**：
   * **问题**：强烈期望（highly desired）被控对象 $G$ 的模型是**最小阶模型**。
   * **原因**：如果 $G$ 不是最小阶的，它会导致Riccati方程的输入（即高阶传递函数）出现问题，可能导致**数值不稳定性**。
   * **后果**：非最小阶模型会导致闭环传递函数中出现**“非常靠近虚轴的不稳定右半平面极点”**（即不稳定的零极点对消失败），这在计算最坏情况增益（`wcgain`）时会引起问题。
   * **建议**：对于运动系统，推荐使用**模态模型**（modal models）以获得最小阶模型。
2. **关于积分器（关键讨论）**：
   * **问题**：这一点直接呼应了图片一中的建模选择。论文指出，系统被建模为**稳定系统**（如附录B-A所示），**而不是使用纯积分器**。
   * **原因**：这样做是为了**“防止在极低频（VLF）范围内的数值不稳定性”**。
   * **带来的新问题（失配）**：真实系统包含纯积分器。因此，在积分器截止频率（例如 1.6e-3 Hz，与图片一中的 0.01 rad/s 是同一概念）以下，估算模型和真实系统之间存在**失配（mismatch）**。
   * **后果**：这种失配会增加低频模型的不确定性。如果输入信号 $r$（参考）或 $d$（扰动）包含非常低的频率成分，这种失配可能导致残差信号 $\epsilon$ 在很长的时间尺度上**“漂移出 $\gamma$ 边界”**，导致误报警。
   * **解决方案**：最简单的方法是调整塑形权重 $\alpha(s)$ 和/或 $\beta(s)$。通过在极低频范围增加它们的增益，迫使后置滤波器（post-filter, 即 $R$）在该频率范围内的增益降低，从而**“消除这种不良影响”**（即滤除低频漂移）。
   * **备注**：作者提到，用于时域仿真（图17）的系统 $G$ 是**不稳定**的（即包含纯积分器），而用于滤波器综合（设计）的则是那个**稳定**的（带漂移积分器）模型。
3. **关于低频不确定性**：
   * **问题**：被控对象的测量数据（系统辨识）在 10 Hz 以下是**不可靠的**。
   * **建议**：如果要将合成的滤波器实际部署到真实设备上，不确定性模型 $G_u$ 应该在 10 Hz 以下包含**更多的不确定性**，以确保设计的鲁棒性。

# VI. EXPERIMENTAL CASE STUDY

## **VI-A.** 建模框架：$G_u$ 、$K$、 $G_d$ 、$G_f$

4输出u，4输出y系统，故障f

<img src="C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251111153835520.png" alt="image-20251111153835520" style="zoom:67%;" />

**不确定性被控对象模型 ($G_u$)**

1. 4x4 的传递函数矩阵，描述从 $u_1...u_4$ 到 $y_1...y_4$ 的动态
2. 模型是通过系统辨识实验（multisine identification）获得的，并被拟合为一个**20阶**的标称模型 $G$
3. 不确定性被建模为**加性不确定性**：$G_u = G + W\Delta$ 
4. $W$ 是一个稳定的权重传递函数（详见附录C-A），$\Delta$ 是范数有界的不确定性模块

**反馈控制器 ($K$)**

1. 实验平台上已经存在一个SISO（单输入单输出）刚体控制器 $K_{rb}$ 。
2. 通过解耦矩阵 $T_u$ 和 $T_y$，这个SISO控制器被扩展为一个完整的 4x4 块控制器 $\hat{K} = T_u K T_y$，用于FDF综合

**扰动模型 ($G_d$)**

1. 系统上的扰动（如地面振动）未被建模 。
2. 假设唯一的扰动来源是**高品质传感器**的测量噪声 。
3. 该噪声被建模为标准差 $\sigma_{std} = 10$ nm。

**故障模型 ($G_f$)**

1. 故障被定义为**两个致动器故障**
2. 故障 $f_1$ 通过致动器u6注入，故障 $f_2$ 通过致动器u3注入（如图18所示）
3. 因此，故障模型 $G_f$ 就是从这两个（未用于控制的）致动器到4个传感器的传递函数矩阵：$G_f = [G_{u3} \quad G_{u6}]$

* [ ] <span style="color:#FF0000;">疑问</span>：致动器u6不是用于控制的致动器，故障在这里注入有什么用？就是光用来产生故障了。模拟两种情况，一种是故障出现在用于控制的执行器里，一种是在执行器外部的故障？或者说在执行器不用于控制时也能检测到故障？

## **VI-B. 鲁棒故障检测滤波器综合**

这是本节的核心，描述了如何设计后置滤波器 $R$。

1. **遇到的问题（放弃了“最优”方案）**：
   1. 论文中提出的“统一解”（Unified Solution，基于Riccati方程）要求上界 $\bar{G}_d(s)$ 必须满足严格的条件（即式(42)
   2. 对于OAT这个复杂的MIMO系统，使用wcgain.m函数找到的上界**不满足**这个条件
   3. 虽然理论上可以通过 $\alpha(s)$ 和 $\beta(s)$ 调谐旋钮来修正，但研究人员发现**没有明确的程序**可以为MIMO系统检查式(42)的条件或执行此修正操作
   4. 此外，他们还遇到了**严重的数值问题**（在VI-D中讨论），导致该Riccati方法**无法使用**
2. **采用的“保守方法”（Conservative Approach）**：
   1. 由于无法使用最优的“统一解”，研究人员转而采用了一种**更保守但保证有效**的方法，该方法不依赖Riccati方程
   2. **步骤1：获得预滤波器 (LCF)**
      1. 使用lncf.m函数计算标称模型 $G$ 的左互质分解 ($\tilde{M}_u, \tilde{N}_u$) 28。
      2. **关键处理**：由于 $G$ 包含积分器（运动系统），为避免数值问题，积分器被移动到左半平面的稳定极点（在0.2 Hz）
   3. **步骤2：设计后置滤波器 $R$**
      1. 构造“扩展扰动矩阵” $\tilde{G}_d(s, \Delta)$（即从 $r$ 和 $d$ 到预残差 $\tilde{\epsilon}$ 的不确定性传递）
      2. 确定该矩阵的**最大奇异值（$\sigma_1$）**包络线，即在所有频率和不确定性下的最大增益（见图20上方的灰色曲线）
      3. 构造一个**SISO**传递函数 $\bar{G}_d(s)$（图20上方的红色曲线），使其**大于等于**步骤2中所有的最大奇异值
      4. 最终的后置滤波器 $R$ 被构造为一个**对角矩阵**：$R = \gamma \bar{G}_d(s)^{-1} I_{n_y}$（其中 $n_y=4$, $\gamma=1$

* **方法对比与权衡**：
  * 这种保守方法 $R$ 保证了约束 $\Vert R(s)\tilde{G}_d(s, \Delta)\Vert_{\infty} \le \gamma$ 得到满足
  * **代价**：“统一解”会产生一个紧密的“椭球体”边界，而这种保守方法产生一个“球体”边界（因为 $R$ 是对角的，所有奇异值相等）
  * 这意味着 $R$ 对扰动/不确定性的**抑制是保守的**（抑制得过多），因此导致对故障的**放大也是保守的**（放大的倍数较少）





这意味着 $R$ 对扰动/不确定性的**抑制是保守的**（抑制得过多），因此导致对故障的**放大也是保守的**（放大的倍数较少） 36。

这导致了一个对角线形式的扰动模型：$G_d = \sigma_{std} I_4$（一个4x4的常数矩阵），这满足了论文理论（定理4）中的假设(A2) 19。

获取FDF的第一步是构造标称系统G的左互质因子$\tilde{M}_u$、$\tilde{N}_u$。这是通过使用Matlab中的lncf.m函数得到的，该函数用于计算归一化左互质因子。由于系统包含积分器，在分解过程中会将这些积分器移至左半平面极点，以获得两个稳定的因子。研究发现，这些**低频极点的频率对于获取有用的残差至关重要**。**极点应“足够快”以跟踪输入信号的动态特性，这意味着频率必须足够高**。在确定左互质因子时，这一点需要牢记。在本案例研究中，极点的频率设置为0.2 Hz。

第二步是后置滤波器的设计，设计步骤如下：

1. 构建如式（37）所定义的扩展扰动矩阵$\widetilde{G}_d(s, \Delta)$。<img src="C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251111110821135.png" alt="image-20251111110821135" style="zoom:80%;" />
2. 确定所有$\Delta$对应的最大奇异值，即$\sigma_1(\widetilde{G}_d(s, \Delta))$，如图20顶部的蓝线所示。<img src="C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251111111217178.png" alt="image-20251111111217178" style="zoom:50%;" />
3. 构建一个单输入单输出（SISO）上界实现$\bar{G}_d(s) \in GH_\infty$，使其在所有$\omega$、$\Delta$下均能覆盖所有$\sigma_1(\widetilde{G}_d(s, \Delta))$，如图20顶部的红线所示。
4. 构建**对角后置滤波器**$R = \gamma \bar{G}_d^{-1}(s)I_{ny}$。该滤波器确保对所有$\Delta$都满足$\|R(s)\widetilde{G}_d(s, \Delta)\|_\infty \leq \gamma$。所得滤波器如图C-B附录中的图25所示，图20底部的曲线显示了当$\gamma =1$时，从$r_d$到$\epsilon$的传递函数的最大奇异值结果。看输出数量决定对角线有多少滤波器。
5. <img src="C:\Users\JC\AppData\Roaming\Typora\typora-user-images\image-20251111111426890.png" alt="image-20251111111426890" style="zoom:50%;" />

该后置滤波器的所有奇异值都等于最大奇异值，这可能导致保守的故障检测性能。此解与共内-外因式分解解（即统一解）的直观关系在于，这种手动构造的上界在每个频率上形成一个ny维“球”，以捕获所有实现$\tilde{G}_d(s, \Delta)$，而非ny维“椭球”。因此，该滤波器对不确定性/干扰的抑制较为保守，从而导致故障对残差的放大也较为保守。另一方面，该滤波器保证满足设计约束，即对所有$\Delta$，有$\|\boldsymbol{R}(s)\tilde{G}_d(s, \Delta)\|_\infty \leq \gamma$，这显然是期望的，并且允许构建残差时域响应的保证边界。

## **VI-C. 实验结果**

实验成功验证了该FDF设计方法。它实现了在存在模型不确定性和扰动的情况下，**对故障和无故障情况的清晰区分**

* [ ] <span style="color:#FF0000;">疑问</span>：但是并没有对具体是哪个执行器产生的故障进行区分

## **VI-D. 讨论 (反思与教训)**

这张图片是实验案例研究（第六节）的“讨论”部分。它反思了实验结果，并解释了为什么论文中更优越的“统一解”（unified solution）方法在实际实验中**没有被使用**。

### **辨识模型质量问题**：

* **积极方面**：实验结果（图20）表明，残差确实满足设计约束，因此可以区分故障和（由模型不确定性及扰动引起的）“不良影响”。
* **局限与警告**：实验中施加的参考信号 $r$ 的基频为 **1 Hz**。
* **问题所在**：正如附录C（图26）所述，1 Hz 处于 **4 Hz 以下**的频段，而模型在该频段的**质量很差**。
  * **模型质量分析**：
  * 不确定性模型 $G_u$ 能够捕捉（覆盖）实测被控对象的动态特性，**频率范围从 4 Hz 到第二个共振频率**。
  * **关键问题**：**在 4 Hz 以下**，辨识实验的**“质量很低”**。模型 $G_u$ 只是“轻微地”捕捉了这一频段，通过增加该频段的不确定性来（部分）补偿这种低质量。
  * 标称模型 $G$ 被正确建模到第二个共振频率，在此之上不确定性会增加，但这被认为不那么重要，因为它“远远超出了 80 Hz 的带宽”。
* **潜在风险**：由于 $G_u$ 模型在 4 Hz 以下不能捕捉所有的动态变化，如果施加一个不同频率（例如2Hz或3Hz）的参考信号，残差**“很可能”会超出（设定的）界限**，导致误报。
* **建议的对策**：为了“安全起见”，研究人员本可以“在 4 Hz 以下将上界 $\bar{G}_d(s)$ 的增益向上平移”（即，使滤波器在该低频段更加保守）。

* [ ] <span style="color:#FF0000;">疑问</span>：为什么模型质量很差？并没有给出原因

  根据您提供的论文内容（特别是 `image_aeb2a1.png`），论文本身并没有详细解释*为什么*最初的系统辨识实验在 4 Hz 以下质量差，但它**明确指出了这一事实及其后果**：

  1. **事实陈述**：论文提到，实验所测量的被控对象（plant）数据是在 4 Hz **以上**才具有“高品质”。
  2. **直接推论**：这反过来意味着，在 4 Hz **以下**的测量数据质量很低或不可靠。
  3. **对模型 $G_u$ 的影响**：由于不确定性模型 $G_u$ 是基于这些测量数据建立的，而 4 Hz 以下的数据质量很差，因此 $G_u$ 模型在这一频段“不能捕捉所有的动态变化”。

  **总结来说：**

  模型 $G_u$ 在 4 Hz 以下质量差，是因为创建该模型所依据的**原始系统辨识实验数据**在该低频范围内的质量很差。模型 $G_u$ 只是反映了它所基于的原始数据的局限性。

  因此，论文作者在讨论（Discussion）中才发出警告：虽然他们在 1 Hz 的参考信号下实验成功了，但如果使用 2 Hz 或 3 Hz 的信号（这仍处于数据质量差的区域），残差很可能会因为模型 $G_u$ 不准确而错误地超出界限。

### **“统一解”失败的原因**：

* **背景**：本节采用了“保守的解决方案”，而不是论文前面提出的（理论上更优的）“统一解”。
* **遇到的主要问题**：在尝试综合“统一解”时，发现在不确定性传递函数矩阵 $\tilde{G}_d(s, \Delta)$ 中出现了**“极低频率（低于 1e-5 Hz）的极点和零点”**。
* **问题根源**：这些极点和零点**并非真实的物理现象**，而是源于被控对象模型 $G$ 本身包含“极低频零点”。
* **问题传递**：这些虚假的零点在计算左互质分解（$\tilde{M}_u, \tilde{N}_u$）时被引入，进而污染了 $\tilde{G}_d(s, \Delta)$。
* **最终后果**：这导致计算出的上界 $\bar{G}_d(s)$ 和最终的后置滤波器 $R$ 包含这些极低频动态，使得残差“无法使用” 。
* **结论/教训**：这凸显了“从0频率开始就拥有一个**精确的模型拟合**是极其重要的”，该模型不应包含“实际上不存在的额外极点和零点”。为了使Riccati方法（统一解）可行，**必须**有一个从 0 Hz 开始就非常精确的模型，且不得包含这些虚假的（non-additional）极点和零点 。



# 统一解失败的原因：虚假的极低频动态与Riccati方程

您正在询问论文中关于**“统一解”（Unified Solution）**在实验中失败的原因，这是鲁棒控制工程实践中一个非常重要的数值稳定性问题。

以下是对这段内容的详细解释：

------



## 什么是“统一解”（Unified Solution）？



在论文中，“统一解”指的是作者提出的**最优鲁棒故障检测滤波器（FDF）设计方法**。这种方法通常基于**线性矩阵不等式（LMI）\**或\**Riccati方程**的求解，旨在实现以下最优性能：

$$\text{找到滤波器 } R(s) \text{ 使得 } \Vert R(s)\tilde{G}_d(s, \Delta)\Vert_{\infty} \le \gamma \text{ 成立，同时最大化 } \Vert R(s)\bar{G}_f(s)\Vert_{\infty}$$

简单来说，它试图找到一个**最优**的 $R(s)$，以**最小保守性**来抑制所有不确定性和扰动（满足 $\gamma$ 约束），同时最大程度地放大故障信号。



##  “统一解”失败的根本原因：虚假的极低频动态



在实际的实验系统 OAT 上，作者尝试使用这种最优方法时，遇到了**致命的数值问题**，导致求解失败或结果不可用。

| **步骤**                                    | **问题细节**                                                 | **导致后果**                                                 |
| ------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **问题根源：标称模型 $G$**                  | **标称模型 $G$ 自身包含“极低频零点”**。这些零点并非系统真实的物理特性（即所谓的**虚假的/non-additional**）。它们通常是由于系统辨识或模型降阶过程中的数值误差引入的。 | -                                                            |
| **问题传递：LCF 分解**                      | 滤波器设计需要对 $G$ 进行**左互质分解（LCF）\**得到 $\tilde{M}_u$ 和 $\tilde{N}_u$。在分解过程中，这些极低频零点被带入并转化为 $\tilde{M}_u$ 和 $\tilde{N}_u$ 中的\**极低频极点**。 | LCF 过程污染了后续设计所需的项。                             |
| **最终后果：$\tilde{G}_d(s, \Delta)$ 矩阵** | 构造出的不确定性传递矩阵 $\tilde{G}_d(s, \Delta)$ 中出现了**极低频率（低于 $1\text{e}-5 \text{ Hz}$）的极点和零点**。 | -                                                            |
| **数值灾难：Riccati/LMI 求解**              | 当尝试求解基于这些矩阵的 Riccati 方程或 LMI 时，由于这些**极靠近虚轴（s=0）**的极点和零点的存在，导致：1. **数值不稳定**，计算无法收敛；2. 即使勉强求出解，计算出的上界 $\bar{G}_d(s)$ 和最终滤波器 $R$ 也包含了这些极低频动态。 | 最终的残差 $\epsilon$ 会被这些极慢的动态主导，使得**残差“无法使用”**（即残差会以极慢的速度漂移，难以设置有效的故障阈值）。 |



## 为什么 V-C 仿真案例没有遇到这个问题？



仿真案例（V-C）使用了 FFR 系统。作者在 V-A 讨论中提到：

> “系统被建模为一个稳定系统，**而不是使用纯积分器**... [积分器] **在 $a = 0.01$ rad/s 处被切断**。”

这意味着在仿真案例中，作者**主动**用一个微小的稳定极点 $s=-0.01$ 来替换了纯积分器 $s=0$。这种操作**人为地消除了数值不稳定性的一个主要来源**，使得 Riccati 求解得以顺利进行。

然而，在 OAT **实验**系统中，系统模型 $G$ 中包含的“极低频零点”是系统辨识数据引入的**隐性误差**，即使是稳定化的操作也无法完全消除，从而再次导致了最优解法的失败。



## 核心教训



这段话的教训对于实际的控制工程项目非常重要：

> “为了使 Riccati 方法（统一解）可行，**必须有一个从 0 Hz 开始就非常精确的模型**，且**不得包含这些虚假的（non-additional）极点和零点**。”

* **精确的低频建模是前提**：最优鲁棒控制方法对模型的**精确度**要求极高，特别是对于低频动态。任何模型失真或虚假动态，都会在依赖矩阵代数的优化算法中被放大，导致数值失败。
* **鲁棒设计工具的局限性**：这段经验表明，即使是先进的鲁棒控制工具箱（如 MATLAB 的 `wcgain` 和 LMI/Riccati 求解器），在处理包含极低频动态的**大型 MIMO 不确定系统**时，仍然面临数值稳定性的挑战。这也是作者最终不得不放弃最优解，转而采用**保守的对角矩阵设计方法**（VI-B 节）的原因。









